{"meta":{"title":"TRAMP 的博客","subtitle":"记录，仅仅为了记录那些","description":"记录，仅仅为了记录那些","author":"张兆玉","url":"https://zhangzhaoyu.github.io"},"pages":[{"title":"关于我","date":"2016-09-28T00:37:32.000Z","updated":"2016-09-28T06:24:17.274Z","comments":false,"path":"about/index.html","permalink":"https://zhangzhaoyu.github.io/about/index.html","excerpt":"","text":"关于我 R&amp;D Engineer Spring Framework 未完待续…"},{"title":"分类","date":"2016-09-28T00:49:40.000Z","updated":"2016-09-28T01:22:39.850Z","comments":false,"path":"categories/index.html","permalink":"https://zhangzhaoyu.github.io/categories/index.html","excerpt":"","text":"本文链接：https://zhangzhaoyu.github.io/categories/index.html"},{"title":"标签云","date":"2016-09-28T00:59:08.000Z","updated":"2016-09-28T01:22:47.190Z","comments":false,"path":"tags/index.html","permalink":"https://zhangzhaoyu.github.io/tags/index.html","excerpt":"","text":"本文链接：https://zhangzhaoyu.github.io/tags/index.html"}],"posts":[{"title":"寻根究底 Spring Security - 概述与快速启动","slug":"spring-security-2016-12-23-spring-security-01","date":"2016-12-23T09:09:45.000Z","updated":"2016-12-23T09:09:46.671Z","comments":true,"path":"2016/12/23/spring-security-2016-12-23-spring-security-01/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/12/23/spring-security-2016-12-23-spring-security-01/","excerpt":"概述Spring Security 为基于Java-EE 的企业级应用提供了综合的安全管理功能。当前有很多方案来解决服务器级别的安全访问机制，但是当部署环境一改变，就有需要花费大量的时间来解决应用的安全问题。Spring Security很好地提供了WAR&amp;EAR 级别的应用安全问题。应用的安全主要包含两个核心概念authentication 和authorization，即认证和授权。通过认证识别身份，通过授权获取能够访问的资源的权限。","text":"概述Spring Security 为基于Java-EE 的企业级应用提供了综合的安全管理功能。当前有很多方案来解决服务器级别的安全访问机制，但是当部署环境一改变，就有需要花费大量的时间来解决应用的安全问题。Spring Security很好地提供了WAR&amp;EAR 级别的应用安全问题。应用的安全主要包含两个核心概念authentication 和authorization，即认证和授权。通过认证识别身份，通过授权获取能够访问的资源的权限。 在应用级别Spring Security 支持各种级别的授权模型，常见的类型包括： HTTP BASIC authentication headers HTTP Digest authentication headers HTTP X.509 client certificate exchange Form-based authentication Jasig Central Authentication Service (otherwise known as CAS, which is a popular open source single sign-on system) LDAP (a very common approach to cross-platform authentication needs, especially in large environments) OpenID authentication 除上面描述之外，还支持其他众多方案，具体参见Spring Security Document。 Spring Security 主要解决以下三个方面的安全问题： 授权Web 请求 授权防范的调用 授权访问个人的领域对象 模块划分Corespring-security-core.jar 包含核心的认证和访问控制类和接口，远程支持，以及供应用使用的基本的spring-security 的接口。支持独立的应用程序，远程的客户端，方法层的安全和基于JDBC的用户存储。包含以下核心目录： org.springframework.security.core org.springframework.security.access org.springframework.security.authentication org.springframework.security.provisioning Remoting提供了与spring remoting 的集成。核心包为org.springframework.security.remoting。 Web包含过滤器(filters)和Web 安全相关的基础代码。当采用spring security web authentication services 和URL-based访问控制时需要使用。主要的包为org.springframework.security.web。 Config包含spring security namespace 的解析代码和Java Configuration Code 的相关接口。当使用XML和Java 注解的方式配置应用时需要用到。主要的包为org.springframework.security.config。 LDAPLDAP authentication and provisioning code。核心的包为org.springframework.security.ldap。 ACL专业的领域对象ACL 实现。用来为领域对象的访问提供安全机制。核心包为org.springframework.security.acls。 CASCAS 客户端的集成工具。当需要集成几个基于CAS的单点登录系统时需要使用。核心包为org.springframework.security.cas。 OpenIDspring-security.openid.jar 提供对OpenID 的支持。核心包为org.springframework.security.openid。需要OpenID4Java。 启动Spring SecuritySpring Web 基于注解的启动机制Java-EE 规范为了实现不通过web.xml 启动Java-EE 项目定义了基于SPI(Service Provider Interface)机制的javax.servlet.ServletContainerInitializer 接口。通过SPI 机制Java-EE容器启动后，会在classpath中寻找上述接口的实现类，并回调该接口提供的方法。Spring Web 就是采用上述机制来实现Web 相关内容的初始化工作的。org.springframework.web.SpringServletContainerInitializer 既为Spring Web中实现javax.servlet.Servletcontainerinitializer 接口的类，具体代码如下：12345678910111213141516171819202122232425262728293031323334353637@HandlesTypes(WebApplicationInitializer.class)public class SpringServletContainerInitializer implements ServletContainerInitializer &#123; @Override public void onStartup(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException &#123; List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;WebApplicationInitializer&gt;(); if (webAppInitializerClasses != null) &#123; for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123; // Be defensive: Some servlet containers provide us with invalid classes, // no matter what @HandlesTypes says... if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp; WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123; try &#123; initializers.add((WebApplicationInitializer) waiClass.newInstance()); &#125; catch (Throwable ex) &#123; throw new ServletException(\"Failed to instantiate WebApplicationInitializer class\", ex); &#125; &#125; &#125; &#125; if (initializers.isEmpty()) &#123; servletContext.log(\"No Spring WebApplicationInitializer types detected on classpath\"); return; &#125; servletContext.log(initializers.size() + \" Spring WebApplicationInitializers detected on classpath\"); AnnotationAwareOrderComparator.sort(initializers); for (WebApplicationInitializer initializer : initializers) &#123; initializer.onStartup(servletContext); &#125; &#125;&#125; 从上述代码上，我们可以看到Spring 在启动后调用了org.springframework.web.WebApplicationInitializer 的实现类的onStartup() 方法。 启动Spring Security启动spring Security 需要注册springSecurityFilterChain，同时Spring Security 提供了WebSecurityConfigurerAdapter 来对Spring Security 进行配置。 非Spring MVC 应用在非基于注解的Spring 应用中不能采用Sevlet 容器的SPI机制来进行启动，因此需要将WebSecurityConfig.class 传递给AbstractSecurityWebApplicationInitializer的构造函数，来启动Spring Security。 1234567891011121314151617181920212223@EnableWebSecurity@EnableGlobalMethodSecurity@EnableGlobalAuthenticationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; // do our self http config, we user WebSecurityConfigurerAdapter @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() .withUser(\"user\").password(\"password\").roles(\"USER\"); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http .authorizeRequests() .anyRequest().authenticated() .and() .formLogin() .loginPage(\"/login\") .permitAll(); &#125;&#125; 1234567public class SecurityWebApplicationInitializer extends AbstractSecurityWebApplicationInitializer &#123; public SecurityWebApplicationInitializer() &#123; super(WebSecurityConfig.class); &#125;&#125; 通过以上配置可以得到以下功能： 所有URL 的访问都需要认证 基于用户名密码的的认证 允许用户logout X-XSS CSRF Fixation Session Fixation 集成了Servlet API： HttpServletRequest#getRemoteUser() HttpServletRequest.html#getUserPrincipal() HttpServletRequest.html#isUserInRole(java.lang.String) HttpServletRequest.html#login(java.lang.String, java.lang.String) HttpServletRequest.html#logout() …… Spring MVC应用的启动基于Spring MVC 的应用由SPI 机制启动，因此需要由Spring MVC来加载Spring Security的配置。因此，注册springsecurityfilterchain仅仅需要实现AbstractSecurityWebApplicationInitializer 即可。1234public class SecurityWebApplicationInitializer extends AbstractSecurityWebApplicationInitializer &#123; // register springSecurityFilterChain // with out exist spring mvc, we use AbstractSecurityWebApplicationInitializer&#125; Spring MVC 的启动Init 类：12345678910111213141516public class WebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class&lt;?&gt;[]&#123;RootConfig.class, WebSecurityConfig.class&#125;; &#125; @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class&lt;?&gt;[]&#123;WebConfig.class&#125;; &#125; @Override protected String[] getServletMappings() &#123; return new String[]&#123;\"/\"&#125;; &#125;&#125; Spring MVC 基于JSP 模板的配置：12345678910111213141516171819202122232425262728293031@Configuration@EnableWebMvc@ComponentScan(\"org.zzy.spring.aop.web\")public class WebConfig extends WebMvcConfigurerAdapter &#123; @Bean public ViewResolver viewResolver() &#123; InternalResourceViewResolver resourceViewResolver = new InternalResourceViewResolver(); resourceViewResolver.setPrefix(\"/WEB-INF/views/\"); resourceViewResolver.setSuffix(\".jsp\"); resourceViewResolver.setViewClass(JstlView.class); resourceViewResolver.setExposeContextBeansAsAttributes(true); return resourceViewResolver; &#125; @Bean public MessageSource messageSource() &#123; /*ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); messageSource.setBasename(\"messages/messages\");*/ ReloadableResourceBundleMessageSource messageSource = new ReloadableResourceBundleMessageSource(); messageSource.setBasename(\"classpath:messages/messages\"); messageSource.setCacheSeconds(10); return messageSource; &#125; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125;&#125; 总结Spring Security 为应用级别的安全访问提供了许多开箱即用的功能。同时，用户也能基于自己的业务需求根据Spring Security暴露的接口进行个性化的开发。相关内容会在后续的n文章中进行介绍。本文对Spring MVC的启动机制进行了详细地址介绍，在此基础上也介绍了Spring Security的启动方式，相信读者会有很大收获。 参考引用 Spring Security Document SPI 机制 Spring MVC 启动机制 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/12/23/spring-security-2016-12-23-spring-security-01/","categories":[{"name":"spring 4.x","slug":"spring-4-x","permalink":"https://zhangzhaoyu.github.io/categories/spring-4-x/"}],"tags":[{"name":"security","slug":"security","permalink":"https://zhangzhaoyu.github.io/tags/security/"}],"keywords":[{"name":"spring 4.x","slug":"spring-4-x","permalink":"https://zhangzhaoyu.github.io/categories/spring-4-x/"}]},{"title":"寻根究底ELKBX - Elasticsearch 概述","slug":"elkbx-2016-12-15-elasticsearch-learning-guide-01","date":"2016-12-15T14:17:26.000Z","updated":"2016-12-15T14:28:01.987Z","comments":true,"path":"2016/12/15/elkbx-2016-12-15-elasticsearch-learning-guide-01/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/12/15/elkbx-2016-12-15-elasticsearch-learning-guide-01/","excerpt":"Elasticsearch 概述Elasticsearch是一个高可扩展的开源的全文(full text) 分析引擎。它允许用户以近乎实时(near real time)的速度对海量的数据进行存储、搜索和分析。同通常作为复杂搜索业务和需求的底层技术存在。Elasticsearch 可以被开发者灵活的运用到众多的场景中，如下： Web商店的商品搜索 ： 此场景下，可以使用Elasticsearch 来存储所有商品的目录和库存，提供搜索和自动的推荐建议。 日志数据的统计分析 ： 采用ELKB 技术栈来对日志进行采集、格式化清洗、存储和索引，是一个比较成熟的方案。 商业智能分析 ： 采用ELKB 技术栈，可以对商业数据进行快速的调查，分析以及对特定的商品对进行追踪。将特定用户感兴趣的数据直接推送给用户。可以采用Kibana 直接对结果进行可视化。","text":"Elasticsearch 概述Elasticsearch是一个高可扩展的开源的全文(full text) 分析引擎。它允许用户以近乎实时(near real time)的速度对海量的数据进行存储、搜索和分析。同通常作为复杂搜索业务和需求的底层技术存在。Elasticsearch 可以被开发者灵活的运用到众多的场景中，如下： Web商店的商品搜索 ： 此场景下，可以使用Elasticsearch 来存储所有商品的目录和库存，提供搜索和自动的推荐建议。 日志数据的统计分析 ： 采用ELKB 技术栈来对日志进行采集、格式化清洗、存储和索引，是一个比较成熟的方案。 商业智能分析 ： 采用ELKB 技术栈，可以对商业数据进行快速的调查，分析以及对特定的商品对进行追踪。将特定用户感兴趣的数据直接推送给用户。可以采用Kibana 直接对结果进行可视化。 基础介绍基本概念近乎实时(Near Realtime)Elasticsearch 是一个近乎实时的搜索平台。这意味着，其有近乎1秒的数据延迟，从你将数据索引到Elasticsearch 到能够从Elasticsearch 中查询中。 集群(cluster)一个集群是拥有多个节点来存储所有的数据，并提跨越所有节点的索引和查询功能。集群通过集群的名字来标识。默认的集群名字是Elasticsearch。Node 通过自己配置的名字来加入对应的集群。 节点(Node)一个节点是一个单机的服务器。集群由多个节点组成。一个节点通过节点的名字在一个集群中进行标识。节点的名字默认会由一个UUID 来标识，也可以自己在配置文件中进行配置。 索引(Index)一个索引是一个具有相似特点的文档的集合。类似于关系型数据库中的数据库。一个索引由其名字进行标识。用户通过索引名字来对索引进行各种操作。 类型(Type)在一个索引内，可以定义多个类型。一个类型就是一个索引的逻辑上的划分。通常类型定义了一系列具有相同字段的文档结构。 文档(Document)文档是能够被检索的数据的最小单位。一个文档可以是一个用户，一件商品。文档采用JSON 的结构来进行存储。实际上，一个文档必须被存储到一个索引的具体类型中。 分片&amp;副本(Shards&amp;Replicas)在单个节点上一个索引可以存储大量的数据，直到硬件的限制。但是，将大量的数据(TB&amp;PB)存储到单个节点会严重的影响数据的查询速度。为了解决数据的安全性和快速查询的需求，Elasticsearch 提供了将数据进行分片和进行多副本的存储。每一个分片都是一个全功能的独立索引。可以被分不到集群中的任意节点。分片可以提供一下功能： 允许你水平的分割和扩展数据的存储空间 允许你以分散的方式并行地对数据进行处理，提供系统整体对外的性能和吞吐量 具体的如何将数据进行分片存储以及查询的时候将数据聚合都由Elasticsearch 来完成，对用户是透明的。 在联网环境，任何时间都可能出现故障。因此，十分有必要地为每一个分片的数据提供一种失败机制。基于此，Elasticsearch 允许一个索引分片的多个副本存在。，并且可以存储在多个不同的节点。副本可以解决一下问题： 分片或者节点失败时，仍然保证高可用性。基于次，应该将不同的副本存储到不同的节点上 允许并行地将查询操作分散到各个不同的节点副本，方便地对系统的吞吐量进行扩展 简而言之，每一个索引都可以被分成多个分片。一个索引可以拥有0到多个的副本。一旦复制了，每一个索引分片都将拥有一个主副本分片和多个分片。分片和副本的数量可以再创建索引的时候指定。当索引创建后，可以随意更新副本的数量，但是不可以更改分片的数量了。 默认的，Elasticsearch 中的每一个索引会拥有5个主分片和1个副本。这意味着，至少需要两个节点组成的集群。总共将拥有5个主分片和5个副本复制分片。 每一个Elasticsearch 的分片都是一个Lucene 的索引。一个索引能够存储的最大的文档数量是Inetger.MAX_VALUE -128 = 2147483519。可以采用_cat/shards api 对分片的大小进行监控。 ELasticsearch 安装JdkElasticsearch 官方推荐Oracle JDK 8(1.8.0_73)以上。因此，在安装前请检查JDK 版本。 12java -versionecho $JAVA_HOME 安装方式Elasticsearch 官方提供各个平台的不同安装方式，包括rpm, deb 和压缩包。本文采用压缩包进行安装： 下载压缩文件 12curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.1.1.tar.gzwget -c https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.1.1.tar.gz 解压缩运行 123tar -zxvf elasticsearch-5.1.1.tar.gzcd elasticsearch-5.1.1/bin./elasticsearch 运行后，默认的集群名字为Elasticsearch， 节点名字为随机的UUID。Elasticsearch 会在9200端口开放RESTFul接口，后文会介绍这些接口。同时在9300 端口监听新加入的节点，组成集群。 其他命令Elasticsearch 默认提供了一些命令行配置， 采用：1./elasticsearch -h 可以查看详细的信息，包括一下列表： -E &lt;KeyValuePair&gt; 配置系统的参数，例如 ./elasticsearch -Ecluster.name=my_cluster_name -Enode.name=my_node_name 配置系统的集群名字和节点名字 -V, --version 查看版本信息，并退出 -d, --daemonize 在后台运行Elasticsearch -h, --help 打印帮助信息 -p, --pidfile &lt;path&gt; 将Elasticsearch 的启动后的PID 保存到文件 -s, --silent 显示很少的日志 -v, --verbose 显示冗长的日志 Elasticsearch 的配置文件提供了大量的可配置属性，在实际的生产环境，可以针对实际的使用来进行配置。详细的参数介绍，会在后文进行阐述。 总结本文作为Elasticsearch 介绍的第一篇，介绍了其使用场景已经相关的概念含义。同时，介绍了Elasticsearch 的基本安装。在此基础上，大家就可以愉快地玩耍了。 参考引用 Elasticsearch getting-started 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/12/15/elkbx-2016-12-15-elasticsearch-learning-guide-01/","categories":[{"name":"elkbx","slug":"elkbx","permalink":"https://zhangzhaoyu.github.io/categories/elkbx/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://zhangzhaoyu.github.io/tags/Elasticsearch/"}],"keywords":[{"name":"elkbx","slug":"elkbx","permalink":"https://zhangzhaoyu.github.io/categories/elkbx/"}]},{"title":"寻根究底 Logging - SLF4J 日志Facade 概述","slug":"spring-boot-logging-slf4j","date":"2016-11-18T13:50:01.000Z","updated":"2016-11-18T15:46:54.231Z","comments":true,"path":"2016/11/18/spring-boot-logging-slf4j/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/11/18/spring-boot-logging-slf4j/","excerpt":"SLF4J 概述SLF4J(Simple Logging Facade for Java) 是一个抽象的Java 日志框架门面。它不关注日志的具体实现方法，会在deployment time自动的发现日志的实现类。目前SLF4J 支持的日志实现框架有java.util.logging，logback 和log4j。SLf4J 在运行时，仅仅只需要依赖slf4j-api-1.7.21.jar。","text":"SLF4J 概述SLF4J(Simple Logging Facade for Java) 是一个抽象的Java 日志框架门面。它不关注日志的具体实现方法，会在deployment time自动的发现日志的实现类。目前SLF4J 支持的日志实现框架有java.util.logging，logback 和log4j。SLf4J 在运行时，仅仅只需要依赖slf4j-api-1.7.21.jar。 SLF4J 详解日志实现框架的切换机制SLF4J 支持多种不同的日志实现框架。要实现各种日志实现框架的切换只需要在classpath 中包含对应的转换和实现JAR 包即可。如下图所示： slf4j-simple-1.7.21.jar : SLF4J 提供的日志简单的输出类，将把所有的错误信息输出到System.err，该实现方法在比较小的应用比较实用。 slf4j-log4j12-1.7.21.jar : 绑定Log4j 的实现，还需要在classpath 中加入log4j.jar。 slf4j-jdk14-1.7.21.jar : 绑定java.util.logging，需要JDK 1.4 以上。 logback-classic-1.0.13.jar : 绑定logback 实现，还需要加入logback-core-1.0.13.jar。logback 是默认实现SLF4J 的日志输出实现类。经作者测试性能要远远高于log4j。 slf4j-jcl-1.7.21.jar : 该绑定会将所有的SLF4J 代理到JCL(Jakarta Commons Logging)。 slf4j-nop-1.7.21.jar : 绑定为了NOP，所有的日志将不会被输出。 需要注意的是不要同时在classpath 包含多个日志实现类。否则SLF4J 会报错。在SLF4J 1.6 之后的版本中，在classpath 没有绑定实现类，不会跑出错误，仅仅是警告提示。 MDC 支持MDC(Mapped Diagnostic Context)基本上来说是一个由日志框架管理的map 对象。应用程序代码可以将key-code 存储在对象上。之后，日志框架可以取出MDC 中的数据，输出到日志信息中。如果日志实现框架支持MDC，SLF4J 将会代理对应的日志框架管理MDC。目前只有log4j 和 logback 支持。 日志桥接通常我们的应用程序会依赖不同的JAR 包，而不同的JAR 又由于各自的选择会有各种不同的日志实现框架。因此，如何在一个应用中来统一日志的输出形式，是一个需要解决的问题。SLF4J 提供了Bridging legacy APIs 来实现该功能。下图描述如在各种日志绑定实现框架下，如果做桥接的实现。 JCL to SLF4J : 从Jakarta Commons Logging 桥接到SLF4J 需要使用jcl-over-slf4j.jar。它实现了JCL 的公共的API 接口，但是底部却是调用的SLF4J。由它替换到commons-logging.jar。同时可以解决commons logging 的classloader 问题。jcl-over-slf4j.jar 不能跟 slf4j-jcl.jar 同时使用。 log4j-over-slf4j : 不改变一行代码的情况下，将log4j 桥接到slf4j。仅仅需要使用log4j-over-slf4j.jar替换log4j.jar。log4j-over-slf4j.jar和slf4j-log4j12.jar 不能同时出现。 jul-to-slf4j : 将java.util.logging 桥接到slf4j。jul-to-slf4j.jar和slf4j-jdk14.jar不能同时出现。 其他功能日志迁移功能SLF4J 提供了现有的日志迁移工具。具体参见。 国际化SLF4J 同时提供了国际话功能。具体参见。 参考引用 SLF4J Manual Bridging legacy APIs SLF4J java doc SLF4J 带注解的源码 SLF4J 测试用例 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/11/18/spring-boot-logging-slf4j/","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://zhangzhaoyu.github.io/categories/Spring-Boot/"}],"tags":[{"name":"SLF4J","slug":"SLF4J","permalink":"https://zhangzhaoyu.github.io/tags/SLF4J/"}],"keywords":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://zhangzhaoyu.github.io/categories/Spring-Boot/"}]},{"title":"寻根究底 Logging - Spring Boot 日志概述","slug":"spring-boot-logging-introduction","date":"2016-11-16T14:07:26.000Z","updated":"2016-11-21T01:56:52.856Z","comments":true,"path":"2016/11/16/spring-boot-logging-introduction/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/11/16/spring-boot-logging-introduction/","excerpt":"Spring Boot 日志概述Spring Boot 采用 Commons Logging 作为内部的日志框架。对于日志的具体实现，则没有限制。默认的提供了对Java Util Logging，Log4J2 和 Logback 的支持。每种方式下，Console 的日志输出，作为默认的日志输出。在默认情况下，采用Starters 来启动Spring Boot 项目，Logback 是默认的日志实现方案。当然，Logback 路由能够保证依赖的包使用的其他日志也可以很好的工作。","text":"Spring Boot 日志概述Spring Boot 采用 Commons Logging 作为内部的日志框架。对于日志的具体实现，则没有限制。默认的提供了对Java Util Logging，Log4J2 和 Logback 的支持。每种方式下，Console 的日志输出，作为默认的日志输出。在默认情况下，采用Starters 来启动Spring Boot 项目，Logback 是默认的日志实现方案。当然，Logback 路由能够保证依赖的包使用的其他日志也可以很好的工作。 默认日志引入Staters 后的日志依赖Spring Boot 采用Starters 的方式引入对应的Jar 后，会对应的引入基础的项目依赖项，包括日志的依赖项。由于apache commons logging 是一个历史悠久的日志框架，Spring 项目在Core 中对其进行了依赖。当采用org.springframework.boot:spring-boot-starter 和 org.springframework.boot:spring-boot-starter-web 构建一个基础的Spring Boot项目时，项目产生的Jar 依赖如下图所示： 由上图可以看出，Spring Boot 的基础spring-boot-starter 引入后，自动引入了SLF4J 提供的桥接功能org.slf4j:jcl-over-slf4j:jar 将JCL 的日志实现桥接到SLF4J 上，而SLF4J 直接采用了logback 日志实现框架。同时，也引入了对其JUL 和Log4j桥接。当引入spring-boot-starter-web 后加入了对org.jboss.logging:jboss-logging:jar 的依赖。关于SLF4J 的具体介绍参见寻根究底 LOGGING - SLF4J 日志FACADE 概述。 日志格式默认的日志格式如下所示： 122014-03-05 10:57:51.112 INFO 45469 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/7.0.522014-03-05 10:57:51.253 INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] 具体的含义如下： 精确到毫秒的日期和时间 Log Level - ERROR，WARN，INFO 或者 TRACE 进程ID --- 具体的日志内容的分隔符 线程名字 Logger Name - 通常是定义日志记录的类名 具体的日志内容 需要注意的是Logback 没有 FATAL 的日志级别，它被映射到ERROR 控制台输出默认的日志配置会将ERROR，WARN 和 INFO级别的日志输出到控制台。我们也可以使用”DEBUG” 模式才输出更多的内容。1$ java -jar myapp.jar --debug 也可以在Spring Boot的配置文件application.properties 中配置debug=true 来开启更多的日志输出功能。此模式只能输出被选择的核心logger 来输出更多的消息，例如内嵌的容器，Hibernate 和spring Boot。我们自己的应用并不会输出Debug 级别的日志。另外同上我们也可以配置trace 模式来输出更多的日志内容，但也只是一个被选择的核心Logger 列表。 Color-coded 输出如果终端支持ANSI，将会输出彩色的日志。可以再application.properties 文件中设置spring.output.ansi.enabled 为always，detect 和never 来覆盖默认的级别，默认为detect。彩色的样式采用%clr 来进行转换。最简单的模式就是日志将根据Level 输出为不同的颜色: FATAL : Red ERROR : Red WARN : Yellow INFO : Green DEBUG : Green TRACE : Green 除此之外，可以指定转换日志时的颜色，通过指定转换选项：1%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;option&#125; option 可以指定为： blue cyan faint green magenta red yellow 文件输出默认情况下，Spring Boot 仅仅将日志输出在控制台。如果需要将日志输出到文件需要在application.properties 中配置logging.file 或者 logging.path。 logging.file : 输出到指定的文件，可以为相对路径或者绝对路径 logging.path : 与logging.file 是互斥的，指定文件的路径，默认的文件名为spring.log 日志文件默认达到10Mb 时，将会从新打开一个文件输出，默认的日志输出级别为ERROR，WARN 和 INFO。需要注意的是日志系统的初始化要早于系统的生命周期，因此logging properties 不能够通过@PropertySource 注解获取。 Logging properties 相对于实际的日志框架是独立的，因此特定的日志的配置参数并不归Spring Boot 管理。 日志等级所有支持的日志系统都可以通过logging.level.*=LEVEL 在application.properties 中配置： 123logging.level.root=WARNlogging.level.org.springframework.web=DEBUGlogging.level.org.hibernate=ERROR 默认条件下，Spring Boot 重新映射了Thymeleaf 的INFO 级别日志到DEBUG 级别。具体可以参见LevelRemappingAppender 类的细节。 自定义配置配置概述通过将不同的日志依赖包添加到classpath 中，Spring Boot 的日志系统能够判断激活不同的日志实现方式。更进一步的配置是将自定义的日志配置文件添加到classpath 中，或者通过Spring 的logging.config 来指定配置文件的位置。 可以通过设置org.springframework.boot.logging.LoggingSystem 系统变量来配置一个特殊的日志系统。对应的设置值应该是LoggingSystem 的实现类。也可以将该变量的值设置为none 来关闭Spring Boot 的日志。 由于日志的初始化早于ApplicationContext 的创建，因此不能够通过@Configuration 文件来进行配置。只能通过系统变量或者外部的传统配置文件来进行配置。 自定义配置文件加载 Logback : logback-spring.xml, logback-spring.groovy, logback.xml 或者logback.groovy Log4j2 : log4j2-spring.xml 或者 log4j2.xml JDK(Java Util Logging) : logging.properties 需要注意的是官方推荐使用-spring 的配置方式。如果使用标准的配置方式，Spring 不能完全控制日志的初始化。此外，当采用executable jar 方式时，Java Util Logging 会产生已知的错误，因此要避免使用。 系统变量为了帮助实现自定义，以下的Spring Environment 变量会被转化为系统变量 logging.exception-conversion-word : LOG_EXCEPTION_CONVERSION_WORD : 日志异常时的转换语 logging.file : LOG_FILE : 默认的日志文件路径和名称配置 logging.path : LOG_PATH : 默认的日志路径配置 logging.pattern.console : CONSOLE_LOG_PATTERN : 控制台日志的格式，只支持logback logging.pattern.file : FILE_LOG_PATTERN : 日志文件中日志的格式，只支持logback logging.pattern.level : LOG_LEVEL_PATTERN : 日志等级的格式渲染，只支持logback PID : PID : 当前进程的ID 如果想要在日志属性中使用占位符，需要使用Spring Boot syntax 而不是对应日志框架的语法。例如Logback 的属性名之间的分隔符为:，而不是其自身默认的:-。 Logback 扩展为了实现Spring 对logback 的扩展，我们需要将logback 的配置文件的名字定义为logback-spring.xml，或者采用logging.config 来指定配置文件的位置。 Spring Boot 可以采用&lt;springProfile&gt; 标签来激活不同的Spring Profile 配置。Profile 片段可以定义在&lt;configuration&gt; 元素的任何位置。可以使用name 属性来指明需要接受的profile 类型。可以用, 来指定多个profile。1234567891011&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt;&lt;/springProfile&gt;&lt;springProfile name=\"dev, staging\"&gt; &lt;!-- configuration to be enabled when the \"dev\" or \"staging\" profiles are active --&gt;&lt;/springProfile&gt;&lt;springProfile name=\"!production\"&gt; &lt;!-- configuration to be enabled when the \"production\" profile is not active --&gt;&lt;/springProfile&gt; Spring Boot 也可以采用&lt;springProperty&gt; 标签来获取在Spring Environment 中定义的属性。也就是说可以在logback 配置文件中获取在application.properties 中定义的变量。通常它也能直接工作在logbak 的&lt;property&gt; 标签中。具体配置如下：123456&lt;springProperty scope=\"context\" name=\"fluentHost\" source=\"myapp.fluentd.host\" defaultValue=\"localhost\"/&gt;&lt;appender name=\"FLUENT\" class=\"ch.qos.logback.more.appenders.DataFluentAppender\"&gt; &lt;remoteHost&gt;$&#123;fluentHost&#125;&lt;/remoteHost&gt; ...&lt;/appender&gt; 此处采用的是RelaxedPropertyResolver 来获取Spring Environment 变量，因此在定义source的时候的变量采用虚线连接时，对应的变量可以松散的匹配。比如my-property-name 将会匹配myPropertyName 和MY_PROPERTY_NAME。 参考引用 Spring Boot Logging 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/11/16/spring-boot-logging-introduction/","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://zhangzhaoyu.github.io/categories/Spring-Boot/"}],"tags":[{"name":"-logging","slug":"logging","permalink":"https://zhangzhaoyu.github.io/tags/logging/"}],"keywords":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://zhangzhaoyu.github.io/categories/Spring-Boot/"}]},{"title":"ActiveMQ 寻根究低 - 点对点模式详解","slug":"jms-activemq-queue-md","date":"2016-10-21T06:52:32.000Z","updated":"2016-12-15T14:33:09.531Z","comments":true,"path":"2016/10/21/jms-activemq-queue-md/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/10/21/jms-activemq-queue-md/","excerpt":"概述本文在ActiveMQ 寻根究低 - JMS 规范概述一问的基础上，探究点对点模式的具体变成实现方案，以及点对点模式在实际应用的的具体场景。","text":"概述本文在ActiveMQ 寻根究低 - JMS 规范概述一问的基础上，探究点对点模式的具体变成实现方案，以及点对点模式在实际应用的的具体场景。 JMS 程序设计模式JMS 程序的模式主要是给予PTP 和 Pub/Sub 配置一些参数的不同来应用到不同的场景中。根据具体的业务对性能、对数据的安全性等再进行最终方案的选型。通用的结构如下图: 点对点(PTP)模式的实现几个通用类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ConnectionUtils &#123; public static ConnectionFactory getConnectionFactory() &#123; ConnectionFactory connectionFactory = new ActiveMQConnectionFactory( ActiveMQConnectionFactory.DEFAULT_USER, ActiveMQConnectionFactory.DEFAULT_PASSWORD, ActiveMQConnectionFactory.DEFAULT_BROKER_URL ); return connectionFactory; &#125; public static void close(Session session, Connection connection) &#123; if (session != null) &#123; try &#123; session.close(); &#125; catch (JMSException e) &#123; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (JMSException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125; &#125; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(MessageProducer producer, Session session, Connection connection) &#123; if (producer != null) &#123; try &#123; producer.close(); &#125; catch (JMSException e) &#123; close(session, connection); &#125; &#125; close(session, connection); &#125; public static void close(MessageConsumer consumer, Session session, Connection connection) &#123; if (consumer != null) &#123; try &#123; consumer.close(); &#125; catch (JMSException e) &#123; close(session, connection); &#125; close(session, connection); &#125; &#125;&#125; 1234567891011121314151617181920class Obj implements Serializable &#123; int age; String name; public Obj() &#123; &#125; public Obj(int age, String name) &#123; this.age = age; this.name = name; &#125; @Override public String toString() &#123; return new ToStringBuilder(this) .append(&quot;age&quot;, age) .append(&quot;name&quot;, name) .toString(); &#125;&#125; PTP 模式生产者非事务方式的生产者非事务的生产者需要将connection.createSession(transacted, acknowledge) 的第一个参数设置为FALSE。第二个参数指明的消息接受者的应答方法。 123456789101112131415161718192021222324252627282930313233343536class PTPSyncQueueProducer implements Runnable &#123; private final static Logger LOG = LoggerFactory.getLogger(PTPSyncQueueProducer.class); Connection connection; Session session; Destination destination; MessageProducer messageProducer; @Override public void run() &#123; int i = 0; while (true) &#123; try &#123; connection = ConnectionUtils.getConnectionFactory().createConnection(); connection.start(); // first param is transacted session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE); destination = session.createQueue(\"PTPSyncQueueProducer\"); messageProducer = session.createProducer(destination); ObjectMessage objectMessage = session.createObjectMessage(); objectMessage.setObject(new Obj(++i, \"littler Bai\")); messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT); messageProducer.setPriority(Message.DEFAULT_PRIORITY); messageProducer.setTimeToLive(Message.DEFAULT_TIME_TO_LIVE); messageProducer.send(objectMessage); LOG.info(\"send &#123;&#125;\", i); TimeUnit.SECONDS.sleep(5); &#125; catch (JMSException e) &#123; ConnectionUtils.close(messageProducer, session, connection); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 基于事务的生成者基于事务的生产者。只有再事务提交时，消息才已打包的方式一起发送到JMS Provider。 123456789101112131415161718192021222324252627282930313233343536public void transactedProducer() &#123; try &#123; connection = ConnectionUtils.getConnectionFactory().createConnection(); connection.start(); // first param is transacted,if true transaction session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE); destination = session.createQueue(\"PTPSyncQueueProducer\"); messageProducer = session.createProducer(destination); messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT); messageProducer.setPriority(Message.DEFAULT_PRIORITY); messageProducer.setTimeToLive(Message.DEFAULT_TIME_TO_LIVE); for (int i = 0; i &lt; 10; i++) &#123; ObjectMessage objectMessage = session.createObjectMessage(); objectMessage.setObject(new Obj(i, \"littler Bai\")); messageProducer.send(objectMessage); LOG.info(\"send &#123;&#125;\", i); &#125; System.out.println(\"begin sleep\"); TimeUnit.SECONDS.sleep(10); session.commit(); &#125; catch (JMSException e) &#123; try &#123; session.rollback(); &#125; catch (JMSException ex) &#123; ex.printStackTrace(); &#125; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; ConnectionUtils.close(messageProducer, session, connection); &#125; &#125; PTP 模式消费者基于阻塞的消费者基于阻塞的消费者采用MessageConsumer.receive(timeout) 方法来阻塞当前线程，循环获取监测的Destination 的消息。12345678910111213141516171819202122232425262728293031class PTPQueueCustomer &#123; Connection connection; Session session; Destination destination; MessageConsumer messageConsumer; public void consume() &#123; try &#123; connection = ConnectionUtils.getConnectionFactory().createConnection(); connection.start(); session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE); destination = session.createQueue(\"PTPSyncQueueProducer\"); messageConsumer = session.createConsumer(destination); while (true) &#123; Message message = messageConsumer.receive(1000); if (message instanceof ObjectMessage) &#123; ObjectMessage objectMessage = (ObjectMessage) message; System.out.println(objectMessage.getObject()); &#125; &#125; &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; finally &#123; ConnectionUtils.close(messageConsumer, session, connection); &#125; &#125; public static void main(String[] args) &#123; //new PTPQueueCustomer().consume(); new PTPQueueCustomer().asyncConsume(); &#125;&#125; 基于MessageListener 的异步消费者基于MessageListener 的异步消费者需要实现该接口，并在MessageConsumer.setMessageListener(listener) 方法上注册。12345678910111213141516171819202122232425262728class QueueMessageListener implements MessageListener &#123; @Override public void onMessage(Message message) &#123; if (message instanceof ObjectMessage) &#123; ObjectMessage objectMessage = (ObjectMessage) message; try &#123; System.out.println(objectMessage.getObject()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public void asyncConsume() &#123; try &#123; connection = ConnectionUtils.getConnectionFactory().createConnection(); connection.start(); session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE); destination = session.createQueue(\"PTPSyncQueueProducer\"); messageConsumer = session.createConsumer(destination); messageConsumer.setMessageListener(new QueueMessageListener()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; 总结虽然PTP 模式，规定了一个消息（Message）只能由一个消费者消费，但是并不意味着一个PTP 的Destination 只能连接一个消费者。因此，PTP 模式典型应用由： 应用到将同一件事情分散到多个处理者。 订单处理系统，如定时抢购，银行纪念币抢兑 一对一系统间调用的解耦 基于PTP 实现request-response 应答模式 参考引用 ActiveMQ 寻根究低 - JMS 规范概述 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/10/21/jms-activemq-queue-md/","categories":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://zhangzhaoyu.github.io/categories/ActiveMQ/"}],"tags":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://zhangzhaoyu.github.io/tags/ActiveMQ/"}],"keywords":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://zhangzhaoyu.github.io/categories/ActiveMQ/"}]},{"title":"ActiveMQ 寻根究低 - JMS 规范概述","slug":"jms-specification-introduction","date":"2016-10-19T06:55:02.000Z","updated":"2016-12-15T14:33:35.531Z","comments":true,"path":"2016/10/19/jms-specification-introduction/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/10/19/jms-specification-introduction/","excerpt":"JMS 概述JMS1.1（Java Message Service）是Java 推出的访问已存在的消息产品的一种标准规范，也被称为消息中间件。 JMS 为Java 语言的客户端和Java 语言的中间曾服务使用这些消息系统提供了一种通用的方法。它主要是定义了消息语义，以及一组与之对应的Java 接口。JMS的规范包容了对Java 编程语言之外的其他语言的支持。","text":"JMS 概述JMS1.1（Java Message Service）是Java 推出的访问已存在的消息产品的一种标准规范，也被称为消息中间件。 JMS 为Java 语言的客户端和Java 语言的中间曾服务使用这些消息系统提供了一种通用的方法。它主要是定义了消息语义，以及一组与之对应的Java 接口。JMS的规范包容了对Java 编程语言之外的其他语言的支持。 JMS 的两种类型点对点（P2P）点对点系统与消息队列一起工作的。大多数队列由管理员创建，并被客户端看做是静态资源。 发布/订阅（Pub/Sub）JMS Pub/Sub 模型定义了客户端如何发布消息到给予内容层次的众所周知的节点和如何从节点订阅消息。 JMS 消息消息（Message）在JMS 中被用来描述企业应用间的异步通信。包括异步请求、响应或事件，它们是被企业应用消费的。JMS 消息有以下基本分组成： 消息头 所有的消息都值相同的头字段集。头字段办函了客户端和提供商都要使用的用于标识和路由消息的值。 属性 除了标准的头字段外，消息提供了一个内置的功能来向消息增加可选的头字段。 应用专有属性 为消息增加应用专有的头字段提供的机制。 标准属性 JMS 定义的一些标准属性，他们相当于可选的头字段。 提供上专有属性 提供商专有的属性。 消息体 JMS 定义了几个消息体类型。这些类型覆盖了大部分当前使用的消息风格。 消息字段头 JMSDestination 包含了消息被发往的目的地。创建消息时可以设置JMSDestination，但是消息发送完毕时，会被更新为发送方指定的JMSDetination。 JMSDeliveryMode 包含了消息发送时指定的转发模式。 NON_PERSISTENT 最多一次的。消息会因JMS Provider 的停止而丢失。 PERSISTENT 有且只有一次。JMS Provider 服务停止重启后不会丢失。 JMSMessageID 包含了一个用于唯一标识由JMS provider发送的每个消息。 JMSTimestamp 包含了消息被发送的时间。但不是消息被真正转发的时间。 JMSCorrelation 客户端可以使用JMSCorrelationID 来链接消息，典型的用法就是将响应消息和请求消息连接起来。 JMSReplyTo 消息被发送时包含一个由客户端支持的目的地。它是回复消息应当被发送的目的地。 JMSRedelivered 当消费者收到带有 JMSRedelivered 的消息头时，表明该消息在过去传输过但没有被确认。JMS Provider 必须对该字段进行设置，当为 true 时即告知消费者该消息是重传的，消费者需要自行处理重复的消息。 JMSType 包含了由客户端在发送消息时指定的消息类型标识。 JMSExpiration 消息的过期时间，其值为当前时间加上存活时间（毫秒）；当存活时间设置为 0 时，该字段的值也被设置为 0 ，表示永不过期。 JMSPriority 包含了消息的优先级。消息的优先级， 0 代表最低优先级， 9 代表最高优先级；一般 0~4 为普通优先级， 5~9 为加快优先级。 消息属性Message 除了定义的头字段外，还有一个内置的功能，就是支持为该消息添加可选头字段。例如setObjectProperty() 等方法。 消息体的格式 SteamMessage 消息体包含的是Java 的原始流，它连续的填充和读。 MapMessage 消息体包含一系列的键值对。键值的顺序没有定义。 TextMessage 消息体包含的是java.lang.String。 ObjectMessage 消息体包含了可序列化的Java 对象。也可以是对象集合。 BytesMessage 消息包含一个未解释的字节流。 消息的确认如果会话是事务性的，那么消息确认自动由commit 处理，切恢复由rollcack 处理。非事物的方式如下： DUPS_OK_ACKNOWLEDGE 该选项称为懒惰的消息传递。该选项只用于可以忍受重复消息的消费者。 AUTO_ACKNOWLEDGE 当消息被成功地从调用接收返回或MessageListener 成功返回时，会话自动确认刻画段的消息接收。 CLIENT_ACKNOWLEDGE 客户端通过调用消息的acknowledge 方法来确认消息。确认一个被消费的消息会自动确认被该会话转发的所有消息。 受管对象JMS 的受管对象是那些包含了JMS 配置信息的对象。这些配置信息通常由管理员配置然后由客户端使用。JMS 的受管对象可以通过JNDI 查找。 Destination 包含了除地址外的提供商特有的配置信息且它支持并发使用。代表了一个打开的TCP/IP Scoket 连接。 它再授权发生的地方创建 它能定义一个独一无二的ClientID 它能够创建Session 它提供连接的元信息，ConnectionMetaData 它支持一个可选的ExceptionListener ConnectionFactory 封装了一系列的提供商的连接配置参数，Client 使用它来创建与JMS Provider 的连接。同时，其支持并发。 常用对象 Connection 表示客户端和JMS 系统之间的连接。Connection 可以产生一个或多个Session。 Session 通过session 创建生产者、消费者和消息等。Session 也提供了事务的功能。 TemporaryQueue和TemporaryTopic 临时目的地通常用作JMSReplayTo 的目的地。 QueueBrower 用来查看队列中的消息，但不删除它们。 QueueRequestor 来简化服务请求，提供一个request 方法来发送请求信息和等待回复。 MessageListener 异步的模式，消息的监听者。一旦注册，消息到达时，就会通知。 ExceptionListener 处理连接的异常信息的地方。 参考引用 JMS 1.1 规范 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/10/19/jms-specification-introduction/","categories":[],"tags":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://zhangzhaoyu.github.io/tags/ActiveMQ/"}],"keywords":[]},{"title":"设计模式寻根究底 - 单例模式(Singleton Pattern)","slug":"introduction-of-singleton-design-pattern","date":"2016-10-08T04:22:45.000Z","updated":"2016-11-18T13:25:21.372Z","comments":true,"path":"2016/10/08/introduction-of-singleton-design-pattern/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/10/08/introduction-of-singleton-design-pattern/","excerpt":"概述单例模式是一个既简单又复杂的模式。简单在它想实现的目标十分容易理解，而又复杂在要写出线程安全的单例模式不是那么容易。单例模式的核心定义是：确保某个类只有一个实例，并提供一个访问该实例的全局访问点(Ensure a class has only instance, and provide a global point of access to it)。","text":"概述单例模式是一个既简单又复杂的模式。简单在它想实现的目标十分容易理解，而又复杂在要写出线程安全的单例模式不是那么容易。单例模式的核心定义是：确保某个类只有一个实例，并提供一个访问该实例的全局访问点(Ensure a class has only instance, and provide a global point of access to it)。 单例模式的实现单例模式的实现分为急切的（Eager）和延迟的(Lazy)，线程安全(Thread-Safe)和非线程安全(Non-Thread-Safe)几种。下面就Java 对单例模式的实现进行介绍。 Eager 模式实现Eager 模式的实现通常在静态的单例字段声明时（或单例类的构造函数）就创建该单例的对象。这样在单例类被Java 虚拟机加载时，就能够实例化该单例。 基于静态域的Eager 模式1234567891011121314151617public class StaticSingleton implements Serializable &#123; private static StaticSingleton INSTANCE = new StaticSingleton(); private StaticSingleton() &#123;&#125; public static StaticSingleton getInstance() &#123; return INSTANCE; &#125; /** * 解决反序列化出现多个实例的问题 * @return */ private Object readResolve() &#123; return INSTANCE; &#125;&#125; 将初始化放到静态块中实现12345678910public class Singleton &#123; private Singleton instance = null; static &#123; instance = new Singleton(); &#125; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return this.instance; &#125; &#125; 基Java Enum 实现的Eager 模式Java 枚举模式实现的单例是被推崇的，因为其具有： 绝对的线程安全的，由Java 虚拟机保证 不会因为反序列化产生对个实例，Enum 在底层实现了readResolve() 方法 由于Enum 类型在Java 底层是由abstract 修饰的类，因此没法被实例化，能够防止反射攻击。因为反射机制可以调用私有的构造器构造对象 123456789101112131415161718192021public enum EnumSingleton &#123; INSTANCE; private Object singleton; public void print(String name) &#123; System.out.println(\"Hello : \" + name); &#125; public Object build() &#123; singleton = new Object(); return singleton; &#125;&#125;class Client &#123; public static void main(String[] args) &#123; EnumSingleton.INSTANCE.print(\"hello\"); Object object = EnumSingleton.INSTANCE.build(); &#125;&#125; Lazy 模式实现Eager 模式的实现可以避免线程的问题，但是当单例对象需要加载的系统资源很多时，会导致系统在启动时很慢。因此，需要一种方式在使用该对象时构造。也就是单例实现的Lazy 模式。 非线程安全的Lazy 模式采用延迟实例化的方式，能够将单例对象的构造延迟到第一次调用时。很显然，该方式是非线程安全（Non-Thread-Safe）的。12345678910111213public class Singleton &#123; private static Singleton singleton = null; private Singleton() &#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; // can be interrupted to other thread singleton = new Singleton(); &#125; return singleton; &#125; &#125; 线程安全的Lazy 模式在方法上加锁，能够保证该单例模式在多线程环境下的安全性，但是性能将严重受到影响。因为单例对象一旦创建就不需要同步读取获得对象上的互斥锁。12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 基于静态内部类的方式内部静态类SingletonHolder 不会在Singleton 类被装载时就被实例化，需要在getInstance() 显示地被调用时才会被加载。因此，也可以实现Lazy 加载。123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 基于DCL 的Lazy 模式DCL（Double Checked Locking）配合volatile 的使用进行双重检查，能够满足线程安全和延迟加载。12345678910111213141516171819/** Lazy load thread safe * Created by zhaoyu on 16-8-31. */public class DoubleCheckedLockingSingleton &#123; private volatile DoubleCheckedLockingSingleton INSTANCE; private DoubleCheckedLockingSingleton() &#123;&#125; public DoubleCheckedLockingSingleton getInstance() &#123; if (INSTANCE == null) &#123; synchronized (DoubleCheckedLockingSingleton.class) &#123; if (INSTANCE == null) &#123; INSTANCE = new DoubleCheckedLockingSingleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 单例模式的使用场景 项目中共享的访问点或共享的数据，如系统的配置信息 创建一个系统消耗过多资源的对象，例如访问IO和数据库等资源 Web 中采用单例模式保持计数器的值，并确保是线程安全的 生成唯一的序列ID 的场景 总结单例模式（Singleton Pattern）作为被广泛使用的一个模式，不仅能够减少系统的内存开销和提高系统的性能，还能够避免对系统资源的过多占用。在使用单例模式时一定要考虑是否在多线程环境下使用。目前，基于Enum 的实现是现在推荐的单例实现方式。总之，单例模式的使用需要在实际环境中根据需求选择合适的实现方式。 参考引用 单例模式 设计模式-单例模式-TRAMP_ZZY 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/10/08/introduction-of-singleton-design-pattern/","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhangzhaoyu.github.io/categories/设计模式/"}],"tags":[{"name":"Singleton","slug":"Singleton","permalink":"https://zhangzhaoyu.github.io/tags/Singleton/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhangzhaoyu.github.io/categories/设计模式/"}]},{"title":"Spring 寻根究底 - Spring 4.x Task 和 Schedule 概述","slug":"spring-task-and-schedule-deep-research","date":"2016-09-30T13:53:00.000Z","updated":"2016-10-08T06:47:16.142Z","comments":true,"path":"2016/09/30/spring-task-and-schedule-deep-research/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/09/30/spring-task-and-schedule-deep-research/","excerpt":"摘要在很多业务场景中，系统都需要用到任务调度系统。例如定期地清理Redis 缓存，周期性地检索某一条件并更新系统的资源等。在现代的应用系统中，快速地响应用户的请求，是用户体验最主要的因素之一。因此在Web 系统中异步地执行任务，也会在很多场景中经常涉及到。本文对任务调度和异步执行的Java 实现进行了总结，主要讲述一下内容： Java 对异步执行和任务调度的支持 Spring 4.X 的异步执行和任务调度实现","text":"摘要在很多业务场景中，系统都需要用到任务调度系统。例如定期地清理Redis 缓存，周期性地检索某一条件并更新系统的资源等。在现代的应用系统中，快速地响应用户的请求，是用户体验最主要的因素之一。因此在Web 系统中异步地执行任务，也会在很多场景中经常涉及到。本文对任务调度和异步执行的Java 实现进行了总结，主要讲述一下内容： Java 对异步执行和任务调度的支持 Spring 4.X 的异步执行和任务调度实现 Java 对异步执行和任务调度的支持异步执行和任务调度底层的语言支撑都是Java 的多线程技术。线程是系统进行独立运行和调度的基本单位。拥有了多线程，系统就拥有了同时处理多项任务的能力。 Java 实现异步调用在Java 中要实现多线程有实现Runnable 接口和扩展Thread 类两种方式。只要将需要异步执行的任务放在run() 方法中，在主线程中启动要执行任务的子线程就可以实现任务的异步执行。如果需要实现基于时间点触发的任务调度，就需要在子线程中循环的检查系统当前的时间跟触发条件是否一致，然后触发任务的执行。该内容属于Java 多线程的基础知识，此处略过不讲。 Java Timer 和 TimeTask 实现任务调度为了便于开发者快速地实现任务调度，Java JDK 对任务调度的功能进行了封装，实现了Timer 和TimerTask 两个工具类。 由上图，我们可以看出TimeTask 抽象类在实现Runnable 接口的基础上增加了任务cancel() 和任务scheduledExecuttionTime() 两个方法。 上图为调度类Timer 的实现。从Timer类的源码，可以看到其采用TaskQueue 来实现对多个TimeTask 的管理。TimerThread 集成自Thread 类，其mainLoop() 用来对任务进行调度。而Timer 类提供了四种重载的schedule() 方法和重载了两种sheduleAtFixedRate() 方法来实现几种基本的任务调度类型。下面的代码是采用Timer 实现的定时系统时间打印程序。 1234567891011public class PrintTimeTask extends TimerTask &#123; @Override public void run() &#123; System.out.println(new Date().toString()); &#125; public static void main(String[] args) &#123; Timer timer = new Timer(\"hello\"); timer.schedule(new PrintTimeTask(), 1000L, 2000L); &#125;&#125; Spring 4.x 中的异步执行和任务调度Spring 4.x 中的异步执行Spring 作为一站式框架，为开发者提供了异步执行和任务调度的抽象接口TaskExecutor 和TaskScheduler。Spring 对这些接口的实现类支持线程池(Thread Pool) 和代理。Spring 提供了对JDK 中Timer和开源的流行任务调度框架Quartz的支持。Spring 通过将关联的Schedule 转化为FactoryBean 来实现。通过Spring 调度框架，开发者可以快速地通过MethodInvokingFactoryBean 来实现将POJO 类的方法转化为任务。 Spring TaskExecutorTaskExecutor 接口扩展自java.util.concurrent.Executor 接口。TaskExecutor 被创建来为其他组件提供线程池调用的抽象。 ThreadPoolTaskExecutor 是TaskExecutor 的最主要实现类之一。该类的核心继承关系如下图所示。 ThreadPoolTaskExecutor 接口扩展了重多的接口，让其具备了更多的能力。要实现异步需要标注@Async 注解： AsyncTaskExecutor 增加了返回结果为Future 的submit() 方法，该方法的参数为Callable 接口。相比Runnable 接口，多了将执行结果返回的功能。 AsyncListenableTaskExecutor 接口允许返回拥有回调功能的ListenableFuture 接口，这样在结果执行完毕是，能够直接回调处理。 123456789101112131415161718192021222324252627282930public class ListenableTask &#123; @Async public ListenableFuture&lt;Integer&gt; compute(int n) &#123; int sum = 0; for (int i = 0; i &lt; n; i++) &#123; sum += i; &#125; return new AsyncResult&lt;&gt;(sum); &#125; static class CallBackImpl implements ListenableFutureCallback&lt;Integer&gt; &#123; @Override public void onFailure(Throwable ex) &#123; System.out.println(ex.getMessage()); &#125; @Override public void onSuccess(Integer result) &#123; System.out.println(result); &#125; &#125; public static void main(String[] args) &#123; ListenableTask listenableTask = new ListenableTask(); ListenableFuture&lt;Integer&gt; listenableFuture = listenableTask.compute(10); listenableFuture.addCallback(new CallBackImpl()); &#125;&#125; ThreadFactory 定义了创建线程的工厂方法，可以扩展该方法实现对Thread 的改造。 基于Java Config 基于注解 当采用基于Java Config 注解配置时，只需要在主配置添加@EnableAsync 注解，Spring 会自动的创建基于ThreadPoolTaskExecutor 实例注入到上下文中。 1234@Configuration@EnableAsyncpublic class AppConfig &#123;&#125; 基于AsyncConfigurer接口自定义 开发者可以自定义Executor 的类型，并且注册异常处理器。 123456789101112131415161718192021@Configurationpublic class TaskConfig implements AsyncConfigurer &#123; @Override public Executor getAsyncExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setMaxPoolSize(100); executor.setCorePoolSize(10); return executor; &#125; @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123; return new AsyncUncaughtExceptionHandler() &#123; @Override public void handleUncaughtException(Throwable ex, Method method, Object... params) &#123; System.out.println(ex.getMessage()); &#125; &#125;; &#125;&#125; 基于XML Config 基于传统XML的配置 基于XML 的形式，采用传统的Java Bean的形式配置ThreadPoolTaskExecutor。然后采用自动注入(autowire, resource,name)的可以直接在Spring Component 中注入Executor。以编程的形式实现异步任务。 123456&lt;bean id=\"taskExecutor\" class=\"org.springframework.scheduling.concurrent. ThreadPoolTaskExecutor\"&gt; &lt;property name=\"corePoolSize\" value=\"5\" /&gt; &lt;property name=\"maxPoolSize\" value=\"10\" /&gt; &lt;property name=\"queueCapacity\" value=\"25\" /&gt;&lt;/bean&gt; 基于task 命名空间的配置 Spring 为任务的执行提供了便利的task 命名空间。当采用基于XML 配置时Spring 会自动地为开发者创建Executor。同时可以在annotation-driven 标签上注册实现了AsyncUncaughtExceptionHandler 接口的异常处理器。 123&lt;!-- config exception handler --&gt;&lt;bean id=\"taskAsyncExceptionHandler\" class=\"org.zzy.spring4.application.schedulie.TaskAsyncExceptionHandler\"/&gt;&lt;task:annotation-driven exception-handler=\"taskAsyncExceptionHandler\" scheduler=\"scheduler\" executor=\"executor\"/&gt; 异步执行的异常处理除了上文提到的两种异常处理方式，Spring 还提供了基于SimpleApplicationEventMulticaster 类的异常处理方式。123456789101112@Beanpublic SimpleApplicationEventMulticaster eventMulticaster(TaskExecutor taskExecutor) &#123; SimpleApplicationEventMulticaster eventMulticaster = new SimpleApplicationEventMulticaster(); eventMulticaster.setTaskExecutor(taskExecutor); eventMulticaster.setErrorHandler(new ErrorHandler() &#123; @Override public void handleError(Throwable t) &#123; System.out.println(t.getMessage()); &#125; &#125;); return eventMulticaster;&#125; Spring 4.x 中任务调度实现Spring 的任务调度主要基于TaskScheduler 接口。ThreadPoolTaskScheduler 是Spring 任务调度的核心实现类。该类提供了大量的重载方法进行任务调度。Trigger 定义了任务被执行的触发条件。Spring 提供了基于Corn 表达式的CornTrigger实现。TaskScheduler 如下图所示。 实现TaskScheduler 接口的ThreadPoolTaskExecutor 继承关系。 基于Java Config 基于注解的配置 当采用基于Java Config 注解配置时，只需要在主配置添加@EnableScheduling 注解，Spring 会自动的创建基于ThreadPoolTaskExecutor 实例注入到上下文中。 1234@Configuration@EnableSchedulingpublic class AppConfig &#123;&#125; 基于SchedulingConfigurer接口自定义 12345678910111213@Configurationpublic class ScheduleConfig implements SchedulingConfigurer &#123; @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; taskRegistrar.setTaskScheduler(new ThreadPoolTaskScheduler()); taskRegistrar.getScheduler().schedule(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"hello\"); &#125; &#125;, new CronTrigger(\"0 15 9-17 * * MON-FRI\")); &#125;&#125; 基于XML Config12&lt;task:annotation-driven scheduler=\"myScheduler\"/&gt;&lt;task:scheduler id=\"myScheduler\" pool-size=\"10\"/&gt; @Scheduled 注解的使用当某个Bean 由Spring 管理生命周期时，就可以方便的使用@Shcheduled 注解将该Bean 的方法准换为基于任务调度的策略。123456789@Scheduled(initialDelay=1000, fixedRate=5000)public void doSomething() &#123; // something that should execute periodically&#125;@Scheduled(cron=\"*/5 * * * * MON-FRI\")public void doSomething() &#123; // something that should execute on weekdays only&#125; task 命名空间中的task:scheduled-tasks该元素能够实现快速地将一个普通Bean 的方法转换为Scheduled 任务的途径。具体如下：123456&lt;task:scheduled-tasks scheduler=\"myScheduler\"&gt; &lt;task:scheduled ref=\"beanA\" method=\"methodA\" fixed-delay=\"5000\" initial-delay=\"1000\"/&gt; &lt;task:scheduled ref=\"beanB\" method=\"methodB\" fixed-rate=\"5000\"/&gt; &lt;task:scheduled ref=\"beanC\" method=\"methodC\" cron=\"*/5 * * * * MON-FRI\"/&gt;&lt;/task:scheduled-tasks&gt;&lt;task:scheduler id=\"myScheduler\" pool-size=\"10\"/&gt; 总结本文着重介绍了JDK 为任务调度提供的基础类Timer。并在此基础上详细介绍了Spring 4.x 的异步执行和任务调度的底层接口设计。并针对常用的模式进行了讲解，并附带了源代码。第三方开源的Quartz 实现了更为强大的任务调度系统，Spring 也对集成Quartz 提供了转换。之后会择机再详细的介绍Quartz 的应用和设计原理。同时，Servlet 3.x 为Web 的异步调用提供了AsyncContext，对基于Web 的异步调用提供了原生的支持，后续的文章也会对此有相应的介绍。 参考引用 Spring Doc Task and Schedule Quartz Corn Wiki Servlet AsyncContext 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/09/30/spring-task-and-schedule-deep-research/","categories":[{"name":"Spring 4.x","slug":"Spring-4-x","permalink":"https://zhangzhaoyu.github.io/categories/Spring-4-x/"}],"tags":[{"name":"Schedule","slug":"Schedule","permalink":"https://zhangzhaoyu.github.io/tags/Schedule/"},{"name":"Task","slug":"Task","permalink":"https://zhangzhaoyu.github.io/tags/Task/"}],"keywords":[{"name":"Spring 4.x","slug":"Spring-4-x","permalink":"https://zhangzhaoyu.github.io/categories/Spring-4-x/"}]},{"title":"流浪者和罂粟花","slug":"tramp-and-poppy-flower","date":"2016-09-27T15:00:00.000Z","updated":"2016-09-30T12:10:04.582Z","comments":true,"path":"2016/09/27/tramp-and-poppy-flower/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/09/27/tramp-and-poppy-flower/","excerpt":"天边的最后一丝光亮终于在黑暗笼罩世界的最后一刻消散在远处的那座山的背后。 渐渐地，世界暗下来了。 月亮清冷的在一朵浓黑的密云里发着幽幽灰光，那光亮好似冻彻心扉的坚冰，若隐若现的冒着丝丝白气，那白气在空中翻腾，扭曲，变形，幻化出许许多多魑魅魍魉，他们面目狰狞地飞向这个世界，唱着狂欢的笙歌，去吞噬，去冻结，去撕扯这个世界。","text":"天边的最后一丝光亮终于在黑暗笼罩世界的最后一刻消散在远处的那座山的背后。 渐渐地，世界暗下来了。 月亮清冷的在一朵浓黑的密云里发着幽幽灰光，那光亮好似冻彻心扉的坚冰，若隐若现的冒着丝丝白气，那白气在空中翻腾，扭曲，变形，幻化出许许多多魑魅魍魉，他们面目狰狞地飞向这个世界，唱着狂欢的笙歌，去吞噬，去冻结，去撕扯这个世界。有一条小路在这轮孤月下面延伸，奔跑，不知道最终要去向的是哪个地方。小路旁边的有一盏灯火在暮色中亮起来。 透过那微弱的灯光，在窗户里面的一个圆桌子旁边围坐一家人，有个神情坚毅里透着憔悴的男人，有个体态瘦削却流露着母爱的女人，有个鼻子里流着鼻涕的小男孩正津津有味的吃着不知道是什么的东西。在小男孩的旁边有一只小狗欢快的摇着尾巴，看着小主人津津有味的吃着的东西，眼睛里有着自己绝对忠诚的小主人。 在这个有着一盏灯的小房子的后面，是一望无际的有着黄色土壤的田地。黑色的风绕过高山，掠过树梢，吹向了这片土地。 哗哗… 阵阵植物叶子簌簌地摩擦的声音，彼此起伏，蔓延开来。风掀起的黑色的叶子，呼啸着奔向对面的那片漆黑之中。 月亮渐渐地完全地被纯黑色的巨大黑幕所吞噬。 黑暗在世界任何一个角落里开着狂欢的派对。吸食着人们内心里最后的那么一点对于理想，自由，爱的追求。 恐慌，恐慌，满世界的恐慌。 黑暗，黑暗，满世界的黑暗。 在那个小屋子里的角落里，一个小男孩抱着一只懒洋洋的小狗甜甜地静静地在安睡。 那是一个美妙的梦，屋后面的那一望无际的植物终于开花了，在小男孩的爸爸妈妈付出了极其艰辛的劳动和汗水之后终于开花了。因为小男孩知道当这些个植物的开花的时候，肯定就是爸爸妈妈展开笑颜的时候了。 曾经很多个夜晚，小男孩对着夜空发呆，希望寻着一颗能够实现他愿望的星星。 在这个梦里，小男孩终于可以在花海奔跑，呵呵的笑声伴着小狗的汪汪叫声，在这片土地里延伸。 一群穿着黑色制服的人顺着那条小路向着这个黑暗里唯一的存在着微弱亮光的地方走来。 树影斑驳，人影可怖。 咚咚… 圆桌旁边男人，内心一惊，随后握紧了拳头。重重地压在桌子。旁边的妻子轻轻地把手放在男人的肩上。 “不要惊醒我的孩子，我们跟你们走！”。 吱吱… 门关上了。 四条人影在那条小道上前行，鞋子跟地面沙子摩擦的声音不时的响起，最后，最后，消失在远处的黑暗之中。 身后的那所小房子里，灯光依旧是那样地微弱。 只是，只是一个小男孩还有一个小狗依然静静地甜甜地睡着。 一夜的黑暗在太阳跳过对面山头的时候消失的无影无踪。 小男孩高兴地奔跑着去平时爸爸妈妈早上起来会去劳作的那片田地里，去告诉他们自己昨天做了一个美丽的梦。 时间渐渐过去了，小男孩有些心慌了，还不见爸爸妈妈。小狗在身后也嗷嗷地叫着，表示着不安。 小男孩疯狂地迈着小脚步在那片田地里穿梭。一朵朵美丽的花朵在他的眼前招摇，挡住了他寻找爸爸妈妈的视线。同时也淹没了小男孩小小身体。 黑夜渐渐地如梦魇般来到了。 在昨夜的那个小屋子里，再也没有了灯光。 哪怕是微弱的。 只是在那条路上站着一个小小男孩和一只小小狗。 在那条路上，小男孩决定去流浪，他没有眼泪，他不知掉为什么要流眼泪，为谁而流。小男孩反过身子，指着小狗，又指了一下与自己相对的另外与一个方向，狗狗很听话的把自己的头掉到了那个方向。 从此，便开始了两个生命体的流浪之旅。 两个身影消失在了夜色之中，只剩下那个小屋和午后的那片天地和田地里一望无际正开着花的植物。 匆匆的，时间流逝。那一个夜晚，那几个人物和故事，也归入到历史的洪流里，渐渐地渺小渺小，渺小到貌似不曾存在过。 一晃十几年过去了，过去了就是过去了。 后来的后来，有人看到了在那片山脚下，在那个曾经的小屋的后面的那片一望无际的田地里，每当植物开花的时候总有一个人影和一只狗游荡在那儿周围。他们的身影时隐实现在那一片罂粟花的海洋里。他们捍卫着在罂粟开花期的每一朵花，他们抵御了在罂粟花最美丽季节任何一个企图采摘哪怕一朵的破坏者。 一人一狗一片罂粟花。 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/09/27/tramp-and-poppy-flower/","categories":[{"name":"diary","slug":"diary","permalink":"https://zhangzhaoyu.github.io/categories/diary/"}],"tags":[{"name":"story","slug":"story","permalink":"https://zhangzhaoyu.github.io/tags/story/"}],"keywords":[{"name":"diary","slug":"diary","permalink":"https://zhangzhaoyu.github.io/categories/diary/"}]},{"title":"雲中的故事","slug":"story-of-the-cloud","date":"2015-05-03T04:12:12.000Z","updated":"2016-09-30T12:10:04.570Z","comments":true,"path":"2015/05/03/story-of-the-cloud/","link":"","permalink":"https://zhangzhaoyu.github.io/2015/05/03/story-of-the-cloud/","excerpt":"飄泊的那朵雲 心里藏着珠兒 一滴是姑娘的淚 一滴是男子的血 淚珠說：我是姑娘溫婉憂傷的情 血珠說：我是男子堅毅孤獨的心","text":"飄泊的那朵雲 心里藏着珠兒 一滴是姑娘的淚 一滴是男子的血 淚珠說：我是姑娘溫婉憂傷的情 血珠說：我是男子堅毅孤獨的心 驚雷一声 淚珠說：我怕 血珠說：你抱着我 她溶進他的心 他感覺自己的心變得好重好重 隨著風蕩 落在山中古寺的一片瓦上 朝日初升 寺中梵音唱起 那滴小雨 對着日和着梵音在瓦上 微笑着再見 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2015/05/03/story-of-the-cloud/","categories":[{"name":"diary","slug":"diary","permalink":"https://zhangzhaoyu.github.io/categories/diary/"}],"tags":[{"name":"story","slug":"story","permalink":"https://zhangzhaoyu.github.io/tags/story/"}],"keywords":[{"name":"diary","slug":"diary","permalink":"https://zhangzhaoyu.github.io/categories/diary/"}]}]}