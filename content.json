{"meta":{"title":"TRAMP 的博客","subtitle":"记录，仅仅为了记录那些","description":"记录，仅仅为了记录那些","author":"张兆玉","url":"https://zhangzhaoyu.github.io"},"pages":[{"title":"关于我","date":"2016-09-28T00:37:32.000Z","updated":"2016-09-28T06:24:17.274Z","comments":false,"path":"about/index.html","permalink":"https://zhangzhaoyu.github.io/about/index.html","excerpt":"","text":"关于我 R&amp;D Engineer Spring Framework 未完待续…"},{"title":"分类","date":"2016-09-28T00:49:40.000Z","updated":"2016-09-28T01:22:39.850Z","comments":false,"path":"categories/index.html","permalink":"https://zhangzhaoyu.github.io/categories/index.html","excerpt":"","text":"本文链接：https://zhangzhaoyu.github.io/categories/index.html"},{"title":"标签云","date":"2016-09-28T00:59:08.000Z","updated":"2016-09-28T01:22:47.190Z","comments":false,"path":"tags/index.html","permalink":"https://zhangzhaoyu.github.io/tags/index.html","excerpt":"","text":"本文链接：https://zhangzhaoyu.github.io/tags/index.html"}],"posts":[{"title":"寻根究底 - Spring Boot 日志概述(1)","slug":"spring-boot-logging-introduction","date":"2016-11-16T14:07:26.000Z","updated":"2016-11-17T09:34:16.487Z","comments":true,"path":"2016/11/16/spring-boot-logging-introduction/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/11/16/spring-boot-logging-introduction/","excerpt":"Spring Boot 日志概述Spring Boot 采用 Commons Logging 作为内部的日志框架。对于日志的具体实现，则没有限制。默认的提供了对Java Util Logging，Log4J2 和 Logback 的支持。每种方式下，Console 的日志输出，作为默认的日志输出。在默认情况下，采用Starters 来启动Spring Boot 项目，Logback 是默认的日志实现方案。当然，Logback 路由能够保证依赖的包使用的其他日志也可以很好的工作。","text":"Spring Boot 日志概述Spring Boot 采用 Commons Logging 作为内部的日志框架。对于日志的具体实现，则没有限制。默认的提供了对Java Util Logging，Log4J2 和 Logback 的支持。每种方式下，Console 的日志输出，作为默认的日志输出。在默认情况下，采用Starters 来启动Spring Boot 项目，Logback 是默认的日志实现方案。当然，Logback 路由能够保证依赖的包使用的其他日志也可以很好的工作。 默认日志日志格式默认的日志格式如下所示： 122014-03-05 10:57:51.112 INFO 45469 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/7.0.522014-03-05 10:57:51.253 INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] 具体的含义如下： 精确到毫秒的日期和时间 Log Level - ERROR，WARN，INFO 或者 TRACE 进程ID --- 具体的日志内容的分隔符 线程名字 Logger Name - 通常是定义日志记录的类名 具体的日志内容 需要注意的是Logback 没有 FATAL 的日志级别，它被映射到ERROR 控制台输出默认的日志配置会将ERROR，WARN 和 INFO级别的日志输出到控制台。我们也可以使用”DEBUG” 模式才输出更多的内容。1$ java -jar myapp.jar --debug 也可以在Spring Boot的配置文件application.properties 中配置debug=true 来开启更多的日志输出功能。此模式只能输出被选择的核心logger 来输出更多的消息，例如内嵌的容器，Hibernate 和spring Boot。我们自己的应用并不会输出Debug 级别的日志。另外同上我们也可以配置trace 模式来输出更多的日志内容，但也只是一个被选择的核心Logger 列表。 Color-coded 输出如果终端支持ANSI，将会输出彩色的日志。可以再application.properties 文件中设置spring.output.ansi.enabled 为always，detect 和never 来覆盖默认的级别，默认为detect。彩色的样式采用%clr 来进行转换。最简单的模式就是日志将根据Level 输出为不同的颜色: FATAL : Red ERROR : Red WARN : Yellow INFO : Green DEBUG : Green TRACE : Green 除此之外，可以指定转换日志时的颜色，通过指定转换选项：1%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;option&#125; option 可以指定为： blue cyan faint green magenta red yellow 文件输出默认情况下，Spring Boot 仅仅将日志输出在控制台。如果需要将日志输出到文件需要在application.properties 中配置logging.file 或者 logging.path。 logging.file : 输出到指定的文件，可以为相对路径或者绝对路径 logging.path : 与logging.file 是互斥的，指定文件的路径，默认的文件名为spring.log 日志文件默认达到10Mb 时，将会从新打开一个文件输出，默认的日志输出级别为ERROR，WARN 和 INFO。需要注意的是日志系统的初始化要早于系统的生命周期，因此logging properties 不能够通过@PropertySource 注解获取。 Logging properties 相对于实际的日志框架是独立的，因此特定的日志的配置参数并不归Spring Boot 管理。 日志等级所有支持的日志系统都可以通过logging.level.*=LEVEL 在application.properties 中配置： 123logging.level.root=WARNlogging.level.org.springframework.web=DEBUGlogging.level.org.hibernate=ERROR 默认条件下，Spring Boot 重新映射了Thymeleaf 的INFO 级别日志到DEBUG 级别。具体可以参见LevelRemappingAppender 类的细节。 自定义配置配置概述通过将不同的日志依赖包添加到classpath 中，Spring Boot 的日志系统能够判断激活不同的日志实现方式。更进一步的配置是将自定义的日志配置文件添加到classpath 中，或者通过Spring 的logging.config 来指定配置文件的位置。 可以通过设置org.springframework.boot.logging.LoggingSystem 系统变量来配置一个特殊的日志系统。对应的设置值应该是LoggingSystem 的实现类。也可以将该变量的值设置为none 来关闭Spring Boot 的日志。 由于日志的初始化早于ApplicationContext 的创建，因此不能够通过@Configuration 文件来进行配置。只能通过系统变量或者外部的传统配置文件来进行配置。 自定义配置文件加载 Logback : logback-spring.xml, logback-spring.groovy, logback.xml 或者logback.groovy Log4j2 : log4j2-spring.xml 或者 log4j2.xml JDK(Java Util Logging) : logging.properties 需要注意的是官方推荐使用-spring 的配置方式。如果使用标准的配置方式，Spring 不能完全控制日志的初始化。此外，当采用executable jar 方式时，Java Util Logging 会产生已知的错误，因此要避免使用。 系统变量为了帮助实现自定义，以下的Spring Environment 变量会被转化为系统变量 logging.exception-conversion-word : LOG_EXCEPTION_CONVERSION_WORD : 日志异常时的转换语 logging.file : LOG_FILE : 默认的日志文件路径和名称配置 logging.path : LOG_PATH : 默认的日志路径配置 logging.pattern.console : CONSOLE_LOG_PATTERN : 控制台日志的格式，只支持logback logging.pattern.file : FILE_LOG_PATTERN : 日志文件中日志的格式，只支持logback logging.pattern.level : LOG_LEVEL_PATTERN : 日志等级的格式渲染，只支持logback PID : PID : 当前进程的ID 如果想要在日志属性中使用占位符，需要使用Spring Boot syntax 而不是对应日志框架的语法。例如Logback 的属性名之间的分隔符为:，而不是其自身默认的:-。 Logback 扩展为了实现Spring 对logback 的扩展，我们需要将logback 的配置文件的名字定义为logback-spring.xml，或者采用logging.config 来指定配置文件的位置。 Spring Boot 可以采用&lt;springProfile&gt; 标签来激活不同的Spring Profile 配置。Profile 片段可以定义在&lt;configuration&gt; 元素的任何位置。可以使用name 属性来指明需要接受的profile 类型。可以用, 来指定多个profile。1234567891011&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt;&lt;/springProfile&gt;&lt;springProfile name=\"dev, staging\"&gt; &lt;!-- configuration to be enabled when the \"dev\" or \"staging\" profiles are active --&gt;&lt;/springProfile&gt;&lt;springProfile name=\"!production\"&gt; &lt;!-- configuration to be enabled when the \"production\" profile is not active --&gt;&lt;/springProfile&gt; Spring Boot 也可以采用&lt;springProperty&gt; 标签来获取在Spring Environment 中定义的属性。也就是说可以在logback 配置文件中获取在application.properties 中定义的变量。通常它也能直接工作在logbak 的&lt;property&gt; 标签中。具体配置如下：123456&lt;springProperty scope=\"context\" name=\"fluentHost\" source=\"myapp.fluentd.host\" defaultValue=\"localhost\"/&gt;&lt;appender name=\"FLUENT\" class=\"ch.qos.logback.more.appenders.DataFluentAppender\"&gt; &lt;remoteHost&gt;$&#123;fluentHost&#125;&lt;/remoteHost&gt; ...&lt;/appender&gt; 此处采用的是RelaxedPropertyResolver 来获取Spring Environment 变量，因此在定义source的时候的变量采用虚线连接时，对应的变量可以松散的匹配。比如my-property-name 将会匹配myPropertyName 和MY_PROPERTY_NAME。 参考引用 Spring Boot Logging 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/11/16/spring-boot-logging-introduction/","categories":[],"tags":[{"name":"-logging","slug":"logging","permalink":"https://zhangzhaoyu.github.io/tags/logging/"}],"keywords":[]},{"title":"ActiveMQ 寻根究低 - 点对点模式详解","slug":"jms-activemq-queue-md","date":"2016-10-21T06:52:32.000Z","updated":"2016-10-24T05:09:47.312Z","comments":true,"path":"2016/10/21/jms-activemq-queue-md/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/10/21/jms-activemq-queue-md/","excerpt":"概述本文在ActiveMQ 寻根究低 - JMS 规范概述一问的基础上，探究点对点模式的具体变成实现方案，以及点对点模式在实际应用的的具体场景。","text":"概述本文在ActiveMQ 寻根究低 - JMS 规范概述一问的基础上，探究点对点模式的具体变成实现方案，以及点对点模式在实际应用的的具体场景。 JMS 程序设计模式JMS 程序的模式主要是给予PTP 和 Pub/Sub 配置一些参数的不同来应用到不同的场景中。根据具体的业务对性能、对数据的安全性等再进行最终方案的选型。通用的结构如下图: 点对点(PTP)模式的实现几个通用类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ConnectionUtils &#123; public static ConnectionFactory getConnectionFactory() &#123; ConnectionFactory connectionFactory = new ActiveMQConnectionFactory( ActiveMQConnectionFactory.DEFAULT_USER, ActiveMQConnectionFactory.DEFAULT_PASSWORD, ActiveMQConnectionFactory.DEFAULT_BROKER_URL ); return connectionFactory; &#125; public static void close(Session session, Connection connection) &#123; if (session != null) &#123; try &#123; session.close(); &#125; catch (JMSException e) &#123; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (JMSException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125; &#125; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void close(MessageProducer producer, Session session, Connection connection) &#123; if (producer != null) &#123; try &#123; producer.close(); &#125; catch (JMSException e) &#123; close(session, connection); &#125; &#125; close(session, connection); &#125; public static void close(MessageConsumer consumer, Session session, Connection connection) &#123; if (consumer != null) &#123; try &#123; consumer.close(); &#125; catch (JMSException e) &#123; close(session, connection); &#125; close(session, connection); &#125; &#125;&#125; 1234567891011121314151617181920class Obj implements Serializable &#123; int age; String name; public Obj() &#123; &#125; public Obj(int age, String name) &#123; this.age = age; this.name = name; &#125; @Override public String toString() &#123; return new ToStringBuilder(this) .append(&quot;age&quot;, age) .append(&quot;name&quot;, name) .toString(); &#125;&#125; PTP 模式生产者非事务方式的生产者非事务的生产者需要将connection.createSession(transacted, acknowledge) 的第一个参数设置为FALSE。第二个参数指明的消息接受者的应答方法。 123456789101112131415161718192021222324252627282930313233343536class PTPSyncQueueProducer implements Runnable &#123; private final static Logger LOG = LoggerFactory.getLogger(PTPSyncQueueProducer.class); Connection connection; Session session; Destination destination; MessageProducer messageProducer; @Override public void run() &#123; int i = 0; while (true) &#123; try &#123; connection = ConnectionUtils.getConnectionFactory().createConnection(); connection.start(); // first param is transacted session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE); destination = session.createQueue(\"PTPSyncQueueProducer\"); messageProducer = session.createProducer(destination); ObjectMessage objectMessage = session.createObjectMessage(); objectMessage.setObject(new Obj(++i, \"littler Bai\")); messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT); messageProducer.setPriority(Message.DEFAULT_PRIORITY); messageProducer.setTimeToLive(Message.DEFAULT_TIME_TO_LIVE); messageProducer.send(objectMessage); LOG.info(\"send &#123;&#125;\", i); TimeUnit.SECONDS.sleep(5); &#125; catch (JMSException e) &#123; ConnectionUtils.close(messageProducer, session, connection); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 基于事务的生成者基于事务的生产者。只有再事务提交时，消息才已打包的方式一起发送到JMS Provider。 123456789101112131415161718192021222324252627282930313233343536public void transactedProducer() &#123; try &#123; connection = ConnectionUtils.getConnectionFactory().createConnection(); connection.start(); // first param is transacted,if true transaction session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE); destination = session.createQueue(\"PTPSyncQueueProducer\"); messageProducer = session.createProducer(destination); messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT); messageProducer.setPriority(Message.DEFAULT_PRIORITY); messageProducer.setTimeToLive(Message.DEFAULT_TIME_TO_LIVE); for (int i = 0; i &lt; 10; i++) &#123; ObjectMessage objectMessage = session.createObjectMessage(); objectMessage.setObject(new Obj(i, \"littler Bai\")); messageProducer.send(objectMessage); LOG.info(\"send &#123;&#125;\", i); &#125; System.out.println(\"begin sleep\"); TimeUnit.SECONDS.sleep(10); session.commit(); &#125; catch (JMSException e) &#123; try &#123; session.rollback(); &#125; catch (JMSException ex) &#123; ex.printStackTrace(); &#125; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; ConnectionUtils.close(messageProducer, session, connection); &#125; &#125; PTP 模式消费者基于阻塞的消费者基于阻塞的消费者采用MessageConsumer.receive(timeout) 方法来阻塞当前线程，循环获取监测的Destination 的消息。12345678910111213141516171819202122232425262728293031class PTPQueueCustomer &#123; Connection connection; Session session; Destination destination; MessageConsumer messageConsumer; public void consume() &#123; try &#123; connection = ConnectionUtils.getConnectionFactory().createConnection(); connection.start(); session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE); destination = session.createQueue(\"PTPSyncQueueProducer\"); messageConsumer = session.createConsumer(destination); while (true) &#123; Message message = messageConsumer.receive(1000); if (message instanceof ObjectMessage) &#123; ObjectMessage objectMessage = (ObjectMessage) message; System.out.println(objectMessage.getObject()); &#125; &#125; &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; finally &#123; ConnectionUtils.close(messageConsumer, session, connection); &#125; &#125; public static void main(String[] args) &#123; //new PTPQueueCustomer().consume(); new PTPQueueCustomer().asyncConsume(); &#125;&#125; 基于MessageListener 的异步消费者基于MessageListener 的异步消费者需要实现该接口，并在MessageConsumer.setMessageListener(listener) 方法上注册。12345678910111213141516171819202122232425262728class QueueMessageListener implements MessageListener &#123; @Override public void onMessage(Message message) &#123; if (message instanceof ObjectMessage) &#123; ObjectMessage objectMessage = (ObjectMessage) message; try &#123; System.out.println(objectMessage.getObject()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public void asyncConsume() &#123; try &#123; connection = ConnectionUtils.getConnectionFactory().createConnection(); connection.start(); session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE); destination = session.createQueue(\"PTPSyncQueueProducer\"); messageConsumer = session.createConsumer(destination); messageConsumer.setMessageListener(new QueueMessageListener()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; 总结虽然PTP 模式，规定了一个消息（Message）只能由一个消费者消费，但是并不意味着一个PTP 的Destination 只能连接一个消费者。因此，PTP 模式典型应用由： 应用到将同一件事情分散到多个处理者。 订单处理系统，如定时抢购，银行纪念币抢兑 一对一系统间调用的解耦 基于PTP 实现request-response 应答模式 参考引用 ActiveMQ 寻根究低 - JMS 规范概述 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/10/21/jms-activemq-queue-md/","categories":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://zhangzhaoyu.github.io/categories/ActiveMQ/"}],"tags":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://zhangzhaoyu.github.io/tags/ActiveMQ/"}],"keywords":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://zhangzhaoyu.github.io/categories/ActiveMQ/"}]},{"title":"ActiveMQ 寻根究低 - JMS 规范概述","slug":"jms-specification-introduction","date":"2016-10-19T06:55:02.000Z","updated":"2016-10-21T04:37:17.255Z","comments":true,"path":"2016/10/19/jms-specification-introduction/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/10/19/jms-specification-introduction/","excerpt":"JMS 概述JMS1.1（Java Message Service）是Java 推出的访问已存在的消息产品的一种标准规范，也被称为消息中间件。 JMS 为Java 语言的客户端和Java 语言的中间曾服务使用这些消息系统提供了一种通用的方法。它主要是定义了消息语义，以及一组与之对应的Java 接口。JMS的规范包容了对Java 编程语言之外的其他语言的支持。","text":"JMS 概述JMS1.1（Java Message Service）是Java 推出的访问已存在的消息产品的一种标准规范，也被称为消息中间件。 JMS 为Java 语言的客户端和Java 语言的中间曾服务使用这些消息系统提供了一种通用的方法。它主要是定义了消息语义，以及一组与之对应的Java 接口。JMS的规范包容了对Java 编程语言之外的其他语言的支持。 JMS 的两种类型点对点（P2P）点对点系统与消息队列一起工作的。大多数队列由管理员创建，并被客户端看做是静态资源。 发布/订阅（Pub/Sub）JMS Pub/Sub 模型定义了客户端如何发布消息到给予内容层次的众所周知的节点和如何从节点订阅消息。 JMS 消息消息（Message）在JMS 中被用来描述企业应用间的异步通信。包括异步请求、响应或事件，它们是被企业应用消费的。JMS 消息有以下基本分组成： 消息头 所有的消息都值相同的头字段集。头字段办函了客户端和提供商都要使用的用于标识和路由消息的值。 属性 除了标准的头字段外，消息提供了一个内置的功能来向消息增加可选的头字段。 应用专有属性 为消息增加应用专有的头字段提供的机制。 标准属性 JMS 定义的一些标准属性，他们相当于可选的头字段。 提供上专有属性 提供商专有的属性。 消息体 JMS 定义了几个消息体类型。这些类型覆盖了大部分当前使用的消息风格。 消息字段头 JMSDestination 包含了消息被发往的目的地。创建消息时可以设置JMSDestination，但是消息发送完毕时，会被更新为发送方指定的JMSDetination。 JMSDeliveryMode 包含了消息发送时指定的转发模式。 NON_PERSISTENT 最多一次的。消息会因JMS Provider 的停止而丢失。 PERSISTENT 有且只有一次。JMS Provider 服务停止重启后不会丢失。 JMSMessageID 包含了一个用于唯一标识由JMS provider发送的每个消息。 JMSTimestamp 包含了消息被发送的时间。但不是消息被真正转发的时间。 JMSCorrelation 客户端可以使用JMSCorrelationID 来链接消息，典型的用法就是将响应消息和请求消息连接起来。 JMSReplyTo 消息被发送时包含一个由客户端支持的目的地。它是回复消息应当被发送的目的地。 JMSRedelivered 当消费者收到带有 JMSRedelivered 的消息头时，表明该消息在过去传输过但没有被确认。JMS Provider 必须对该字段进行设置，当为 true 时即告知消费者该消息是重传的，消费者需要自行处理重复的消息。 JMSType 包含了由客户端在发送消息时指定的消息类型标识。 JMSExpiration 消息的过期时间，其值为当前时间加上存活时间（毫秒）；当存活时间设置为 0 时，该字段的值也被设置为 0 ，表示永不过期。 JMSPriority 包含了消息的优先级。消息的优先级， 0 代表最低优先级， 9 代表最高优先级；一般 0~4 为普通优先级， 5~9 为加快优先级。 消息属性Message 除了定义的头字段外，还有一个内置的功能，就是支持为该消息添加可选头字段。例如setObjectProperty() 等方法。 消息体的格式 SteamMessage 消息体包含的是Java 的原始流，它连续的填充和读。 MapMessage 消息体包含一系列的键值对。键值的顺序没有定义。 TextMessage 消息体包含的是java.lang.String。 ObjectMessage 消息体包含了可序列化的Java 对象。也可以是对象集合。 BytesMessage 消息包含一个未解释的字节流。 消息的确认如果会话是事务性的，那么消息确认自动由commit 处理，切恢复由rollcack 处理。非事物的方式如下： DUPS_OK_ACKNOWLEDGE 该选项称为懒惰的消息传递。该选项只用于可以忍受重复消息的消费者。 AUTO_ACKNOWLEDGE 当消息被成功地从调用接收返回或MessageListener 成功返回时，会话自动确认刻画段的消息接收。 CLIENT_ACKNOWLEDGE 客户端通过调用消息的acknowledge 方法来确认消息。确认一个被消费的消息会自动确认被该会话转发的所有消息。 受管对象JMS 的受管对象是那些包含了JMS 配置信息的对象。这些配置信息通常由管理员配置然后由客户端使用。JMS 的受管对象可以通过JNDI 查找。 Destination 包含了除地址外的提供商特有的配置信息且它支持并发使用。代表了一个打开的TCP/IP Scoket 连接。 它再授权发生的地方创建 它能定义一个独一无二的ClientID 它能够创建Session 它提供连接的元信息，ConnectionMetaData 它支持一个可选的ExceptionListener ConnectionFactory 封装了一系列的提供商的连接配置参数，Client 使用它来创建与JMS Provider 的连接。同时，其支持并发。 常用对象 Connection 表示客户端和JMS 系统之间的连接。Connection 可以产生一个或多个Session。 Session 通过session 创建生产者、消费者和消息等。Session 也提供了事务的功能。 TemporaryQueue和TemporaryTopic 临时目的地通常用作JMSReplayTo 的目的地。 QueueBrower 用来查看队列中的消息，但不删除它们。 QueueRequestor 来简化服务请求，提供一个request 方法来发送请求信息和等待回复。 MessageListener 异步的模式，消息的监听者。一旦注册，消息到达时，就会通知。 ExceptionListener 处理连接的异常信息的地方。 参考引用 JMS 1.1 规范 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/10/19/jms-specification-introduction/","categories":[],"tags":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"https://zhangzhaoyu.github.io/tags/ActiveMQ/"}],"keywords":[]},{"title":"设计模式寻根究底 - 单例模式(Singleton Pattern)","slug":"introduction-of-singleton-design-pattern","date":"2016-10-08T04:22:45.000Z","updated":"2016-11-18T13:25:21.372Z","comments":true,"path":"2016/10/08/introduction-of-singleton-design-pattern/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/10/08/introduction-of-singleton-design-pattern/","excerpt":"概述单例模式是一个既简单又复杂的模式。简单在它想实现的目标十分容易理解，而又复杂在要写出线程安全的单例模式不是那么容易。单例模式的核心定义是：确保某个类只有一个实例，并提供一个访问该实例的全局访问点(Ensure a class has only instance, and provide a global point of access to it)。","text":"概述单例模式是一个既简单又复杂的模式。简单在它想实现的目标十分容易理解，而又复杂在要写出线程安全的单例模式不是那么容易。单例模式的核心定义是：确保某个类只有一个实例，并提供一个访问该实例的全局访问点(Ensure a class has only instance, and provide a global point of access to it)。 单例模式的实现单例模式的实现分为急切的（Eager）和延迟的(Lazy)，线程安全(Thread-Safe)和非线程安全(Non-Thread-Safe)几种。下面就Java 对单例模式的实现进行介绍。 Eager 模式实现Eager 模式的实现通常在静态的单例字段声明时（或单例类的构造函数）就创建该单例的对象。这样在单例类被Java 虚拟机加载时，就能够实例化该单例。 基于静态域的Eager 模式1234567891011121314151617public class StaticSingleton implements Serializable &#123; private static StaticSingleton INSTANCE = new StaticSingleton(); private StaticSingleton() &#123;&#125; public static StaticSingleton getInstance() &#123; return INSTANCE; &#125; /** * 解决反序列化出现多个实例的问题 * @return */ private Object readResolve() &#123; return INSTANCE; &#125;&#125; 将初始化放到静态块中实现12345678910public class Singleton &#123; private Singleton instance = null; static &#123; instance = new Singleton(); &#125; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return this.instance; &#125; &#125; 基Java Enum 实现的Eager 模式Java 枚举模式实现的单例是被推崇的，因为其具有： 绝对的线程安全的，由Java 虚拟机保证 不会因为反序列化产生对个实例，Enum 在底层实现了readResolve() 方法 由于Enum 类型在Java 底层是由abstract 修饰的类，因此没法被实例化，能够防止反射攻击。因为反射机制可以调用私有的构造器构造对象 123456789101112131415161718192021public enum EnumSingleton &#123; INSTANCE; private Object singleton; public void print(String name) &#123; System.out.println(\"Hello : \" + name); &#125; public Object build() &#123; singleton = new Object(); return singleton; &#125;&#125;class Client &#123; public static void main(String[] args) &#123; EnumSingleton.INSTANCE.print(\"hello\"); Object object = EnumSingleton.INSTANCE.build(); &#125;&#125; Lazy 模式实现Eager 模式的实现可以避免线程的问题，但是当单例对象需要加载的系统资源很多时，会导致系统在启动时很慢。因此，需要一种方式在使用该对象时构造。也就是单例实现的Lazy 模式。 非线程安全的Lazy 模式采用延迟实例化的方式，能够将单例对象的构造延迟到第一次调用时。很显然，该方式是非线程安全（Non-Thread-Safe）的。12345678910111213public class Singleton &#123; private static Singleton singleton = null; private Singleton() &#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; // can be interrupted to other thread singleton = new Singleton(); &#125; return singleton; &#125; &#125; 线程安全的Lazy 模式在方法上加锁，能够保证该单例模式在多线程环境下的安全性，但是性能将严重受到影响。因为单例对象一旦创建就不需要同步读取获得对象上的互斥锁。12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 基于静态内部类的方式内部静态类SingletonHolder 不会在Singleton 类被装载时就被实例化，需要在getInstance() 显示地被调用时才会被加载。因此，也可以实现Lazy 加载。123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 基于DCL 的Lazy 模式DCL（Double Checked Locking）配合volatile 的使用进行双重检查，能够满足线程安全和延迟加载。12345678910111213141516171819/** Lazy load thread safe * Created by zhaoyu on 16-8-31. */public class DoubleCheckedLockingSingleton &#123; private volatile DoubleCheckedLockingSingleton INSTANCE; private DoubleCheckedLockingSingleton() &#123;&#125; public DoubleCheckedLockingSingleton getInstance() &#123; if (INSTANCE == null) &#123; synchronized (DoubleCheckedLockingSingleton.class) &#123; if (INSTANCE == null) &#123; INSTANCE = new DoubleCheckedLockingSingleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125; 单例模式的使用场景 项目中共享的访问点或共享的数据，如系统的配置信息 创建一个系统消耗过多资源的对象，例如访问IO和数据库等资源 Web 中采用单例模式保持计数器的值，并确保是线程安全的 生成唯一的序列ID 的场景 总结单例模式（Singleton Pattern）作为被广泛使用的一个模式，不仅能够减少系统的内存开销和提高系统的性能，还能够避免对系统资源的过多占用。在使用单例模式时一定要考虑是否在多线程环境下使用。目前，基于Enum 的实现是现在推荐的单例实现方式。总之，单例模式的使用需要在实际环境中根据需求选择合适的实现方式。 参考引用 单例模式 设计模式-单例模式-TRAMP_ZZY 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/10/08/introduction-of-singleton-design-pattern/","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhangzhaoyu.github.io/categories/设计模式/"}],"tags":[{"name":"Singleton","slug":"Singleton","permalink":"https://zhangzhaoyu.github.io/tags/Singleton/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://zhangzhaoyu.github.io/categories/设计模式/"}]},{"title":"Spring 寻根究底 - Spring 4.x Task 和 Schedule 概述","slug":"spring-task-and-schedule-deep-research","date":"2016-09-30T13:53:00.000Z","updated":"2016-10-08T06:47:16.142Z","comments":true,"path":"2016/09/30/spring-task-and-schedule-deep-research/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/09/30/spring-task-and-schedule-deep-research/","excerpt":"摘要在很多业务场景中，系统都需要用到任务调度系统。例如定期地清理Redis 缓存，周期性地检索某一条件并更新系统的资源等。在现代的应用系统中，快速地响应用户的请求，是用户体验最主要的因素之一。因此在Web 系统中异步地执行任务，也会在很多场景中经常涉及到。本文对任务调度和异步执行的Java 实现进行了总结，主要讲述一下内容： Java 对异步执行和任务调度的支持 Spring 4.X 的异步执行和任务调度实现","text":"摘要在很多业务场景中，系统都需要用到任务调度系统。例如定期地清理Redis 缓存，周期性地检索某一条件并更新系统的资源等。在现代的应用系统中，快速地响应用户的请求，是用户体验最主要的因素之一。因此在Web 系统中异步地执行任务，也会在很多场景中经常涉及到。本文对任务调度和异步执行的Java 实现进行了总结，主要讲述一下内容： Java 对异步执行和任务调度的支持 Spring 4.X 的异步执行和任务调度实现 Java 对异步执行和任务调度的支持异步执行和任务调度底层的语言支撑都是Java 的多线程技术。线程是系统进行独立运行和调度的基本单位。拥有了多线程，系统就拥有了同时处理多项任务的能力。 Java 实现异步调用在Java 中要实现多线程有实现Runnable 接口和扩展Thread 类两种方式。只要将需要异步执行的任务放在run() 方法中，在主线程中启动要执行任务的子线程就可以实现任务的异步执行。如果需要实现基于时间点触发的任务调度，就需要在子线程中循环的检查系统当前的时间跟触发条件是否一致，然后触发任务的执行。该内容属于Java 多线程的基础知识，此处略过不讲。 Java Timer 和 TimeTask 实现任务调度为了便于开发者快速地实现任务调度，Java JDK 对任务调度的功能进行了封装，实现了Timer 和TimerTask 两个工具类。 由上图，我们可以看出TimeTask 抽象类在实现Runnable 接口的基础上增加了任务cancel() 和任务scheduledExecuttionTime() 两个方法。 上图为调度类Timer 的实现。从Timer类的源码，可以看到其采用TaskQueue 来实现对多个TimeTask 的管理。TimerThread 集成自Thread 类，其mainLoop() 用来对任务进行调度。而Timer 类提供了四种重载的schedule() 方法和重载了两种sheduleAtFixedRate() 方法来实现几种基本的任务调度类型。下面的代码是采用Timer 实现的定时系统时间打印程序。 1234567891011public class PrintTimeTask extends TimerTask &#123; @Override public void run() &#123; System.out.println(new Date().toString()); &#125; public static void main(String[] args) &#123; Timer timer = new Timer(\"hello\"); timer.schedule(new PrintTimeTask(), 1000L, 2000L); &#125;&#125; Spring 4.x 中的异步执行和任务调度Spring 4.x 中的异步执行Spring 作为一站式框架，为开发者提供了异步执行和任务调度的抽象接口TaskExecutor 和TaskScheduler。Spring 对这些接口的实现类支持线程池(Thread Pool) 和代理。Spring 提供了对JDK 中Timer和开源的流行任务调度框架Quartz的支持。Spring 通过将关联的Schedule 转化为FactoryBean 来实现。通过Spring 调度框架，开发者可以快速地通过MethodInvokingFactoryBean 来实现将POJO 类的方法转化为任务。 Spring TaskExecutorTaskExecutor 接口扩展自java.util.concurrent.Executor 接口。TaskExecutor 被创建来为其他组件提供线程池调用的抽象。 ThreadPoolTaskExecutor 是TaskExecutor 的最主要实现类之一。该类的核心继承关系如下图所示。 ThreadPoolTaskExecutor 接口扩展了重多的接口，让其具备了更多的能力。要实现异步需要标注@Async 注解： AsyncTaskExecutor 增加了返回结果为Future 的submit() 方法，该方法的参数为Callable 接口。相比Runnable 接口，多了将执行结果返回的功能。 AsyncListenableTaskExecutor 接口允许返回拥有回调功能的ListenableFuture 接口，这样在结果执行完毕是，能够直接回调处理。 123456789101112131415161718192021222324252627282930public class ListenableTask &#123; @Async public ListenableFuture&lt;Integer&gt; compute(int n) &#123; int sum = 0; for (int i = 0; i &lt; n; i++) &#123; sum += i; &#125; return new AsyncResult&lt;&gt;(sum); &#125; static class CallBackImpl implements ListenableFutureCallback&lt;Integer&gt; &#123; @Override public void onFailure(Throwable ex) &#123; System.out.println(ex.getMessage()); &#125; @Override public void onSuccess(Integer result) &#123; System.out.println(result); &#125; &#125; public static void main(String[] args) &#123; ListenableTask listenableTask = new ListenableTask(); ListenableFuture&lt;Integer&gt; listenableFuture = listenableTask.compute(10); listenableFuture.addCallback(new CallBackImpl()); &#125;&#125; ThreadFactory 定义了创建线程的工厂方法，可以扩展该方法实现对Thread 的改造。 基于Java Config 基于注解 当采用基于Java Config 注解配置时，只需要在主配置添加@EnableAsync 注解，Spring 会自动的创建基于ThreadPoolTaskExecutor 实例注入到上下文中。 1234@Configuration@EnableAsyncpublic class AppConfig &#123;&#125; 基于AsyncConfigurer接口自定义 开发者可以自定义Executor 的类型，并且注册异常处理器。 123456789101112131415161718192021@Configurationpublic class TaskConfig implements AsyncConfigurer &#123; @Override public Executor getAsyncExecutor() &#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setMaxPoolSize(100); executor.setCorePoolSize(10); return executor; &#125; @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123; return new AsyncUncaughtExceptionHandler() &#123; @Override public void handleUncaughtException(Throwable ex, Method method, Object... params) &#123; System.out.println(ex.getMessage()); &#125; &#125;; &#125;&#125; 基于XML Config 基于传统XML的配置 基于XML 的形式，采用传统的Java Bean的形式配置ThreadPoolTaskExecutor。然后采用自动注入(autowire, resource,name)的可以直接在Spring Component 中注入Executor。以编程的形式实现异步任务。 123456&lt;bean id=\"taskExecutor\" class=\"org.springframework.scheduling.concurrent. ThreadPoolTaskExecutor\"&gt; &lt;property name=\"corePoolSize\" value=\"5\" /&gt; &lt;property name=\"maxPoolSize\" value=\"10\" /&gt; &lt;property name=\"queueCapacity\" value=\"25\" /&gt;&lt;/bean&gt; 基于task 命名空间的配置 Spring 为任务的执行提供了便利的task 命名空间。当采用基于XML 配置时Spring 会自动地为开发者创建Executor。同时可以在annotation-driven 标签上注册实现了AsyncUncaughtExceptionHandler 接口的异常处理器。 123&lt;!-- config exception handler --&gt;&lt;bean id=\"taskAsyncExceptionHandler\" class=\"org.zzy.spring4.application.schedulie.TaskAsyncExceptionHandler\"/&gt;&lt;task:annotation-driven exception-handler=\"taskAsyncExceptionHandler\" scheduler=\"scheduler\" executor=\"executor\"/&gt; 异步执行的异常处理除了上文提到的两种异常处理方式，Spring 还提供了基于SimpleApplicationEventMulticaster 类的异常处理方式。123456789101112@Beanpublic SimpleApplicationEventMulticaster eventMulticaster(TaskExecutor taskExecutor) &#123; SimpleApplicationEventMulticaster eventMulticaster = new SimpleApplicationEventMulticaster(); eventMulticaster.setTaskExecutor(taskExecutor); eventMulticaster.setErrorHandler(new ErrorHandler() &#123; @Override public void handleError(Throwable t) &#123; System.out.println(t.getMessage()); &#125; &#125;); return eventMulticaster;&#125; Spring 4.x 中任务调度实现Spring 的任务调度主要基于TaskScheduler 接口。ThreadPoolTaskScheduler 是Spring 任务调度的核心实现类。该类提供了大量的重载方法进行任务调度。Trigger 定义了任务被执行的触发条件。Spring 提供了基于Corn 表达式的CornTrigger实现。TaskScheduler 如下图所示。 实现TaskScheduler 接口的ThreadPoolTaskExecutor 继承关系。 基于Java Config 基于注解的配置 当采用基于Java Config 注解配置时，只需要在主配置添加@EnableScheduling 注解，Spring 会自动的创建基于ThreadPoolTaskExecutor 实例注入到上下文中。 1234@Configuration@EnableSchedulingpublic class AppConfig &#123;&#125; 基于SchedulingConfigurer接口自定义 12345678910111213@Configurationpublic class ScheduleConfig implements SchedulingConfigurer &#123; @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123; taskRegistrar.setTaskScheduler(new ThreadPoolTaskScheduler()); taskRegistrar.getScheduler().schedule(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"hello\"); &#125; &#125;, new CronTrigger(\"0 15 9-17 * * MON-FRI\")); &#125;&#125; 基于XML Config12&lt;task:annotation-driven scheduler=\"myScheduler\"/&gt;&lt;task:scheduler id=\"myScheduler\" pool-size=\"10\"/&gt; @Scheduled 注解的使用当某个Bean 由Spring 管理生命周期时，就可以方便的使用@Shcheduled 注解将该Bean 的方法准换为基于任务调度的策略。123456789@Scheduled(initialDelay=1000, fixedRate=5000)public void doSomething() &#123; // something that should execute periodically&#125;@Scheduled(cron=\"*/5 * * * * MON-FRI\")public void doSomething() &#123; // something that should execute on weekdays only&#125; task 命名空间中的task:scheduled-tasks该元素能够实现快速地将一个普通Bean 的方法转换为Scheduled 任务的途径。具体如下：123456&lt;task:scheduled-tasks scheduler=\"myScheduler\"&gt; &lt;task:scheduled ref=\"beanA\" method=\"methodA\" fixed-delay=\"5000\" initial-delay=\"1000\"/&gt; &lt;task:scheduled ref=\"beanB\" method=\"methodB\" fixed-rate=\"5000\"/&gt; &lt;task:scheduled ref=\"beanC\" method=\"methodC\" cron=\"*/5 * * * * MON-FRI\"/&gt;&lt;/task:scheduled-tasks&gt;&lt;task:scheduler id=\"myScheduler\" pool-size=\"10\"/&gt; 总结本文着重介绍了JDK 为任务调度提供的基础类Timer。并在此基础上详细介绍了Spring 4.x 的异步执行和任务调度的底层接口设计。并针对常用的模式进行了讲解，并附带了源代码。第三方开源的Quartz 实现了更为强大的任务调度系统，Spring 也对集成Quartz 提供了转换。之后会择机再详细的介绍Quartz 的应用和设计原理。同时，Servlet 3.x 为Web 的异步调用提供了AsyncContext，对基于Web 的异步调用提供了原生的支持，后续的文章也会对此有相应的介绍。 参考引用 Spring Doc Task and Schedule Quartz Corn Wiki Servlet AsyncContext 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/09/30/spring-task-and-schedule-deep-research/","categories":[{"name":"Spring 4.x","slug":"Spring-4-x","permalink":"https://zhangzhaoyu.github.io/categories/Spring-4-x/"}],"tags":[{"name":"Schedule","slug":"Schedule","permalink":"https://zhangzhaoyu.github.io/tags/Schedule/"},{"name":"Task","slug":"Task","permalink":"https://zhangzhaoyu.github.io/tags/Task/"}],"keywords":[{"name":"Spring 4.x","slug":"Spring-4-x","permalink":"https://zhangzhaoyu.github.io/categories/Spring-4-x/"}]},{"title":"流浪者和罂粟花","slug":"tramp-and-poppy-flower","date":"2016-09-27T15:00:00.000Z","updated":"2016-09-30T12:10:04.582Z","comments":true,"path":"2016/09/27/tramp-and-poppy-flower/","link":"","permalink":"https://zhangzhaoyu.github.io/2016/09/27/tramp-and-poppy-flower/","excerpt":"天边的最后一丝光亮终于在黑暗笼罩世界的最后一刻消散在远处的那座山的背后。 渐渐地，世界暗下来了。 月亮清冷的在一朵浓黑的密云里发着幽幽灰光，那光亮好似冻彻心扉的坚冰，若隐若现的冒着丝丝白气，那白气在空中翻腾，扭曲，变形，幻化出许许多多魑魅魍魉，他们面目狰狞地飞向这个世界，唱着狂欢的笙歌，去吞噬，去冻结，去撕扯这个世界。","text":"天边的最后一丝光亮终于在黑暗笼罩世界的最后一刻消散在远处的那座山的背后。 渐渐地，世界暗下来了。 月亮清冷的在一朵浓黑的密云里发着幽幽灰光，那光亮好似冻彻心扉的坚冰，若隐若现的冒着丝丝白气，那白气在空中翻腾，扭曲，变形，幻化出许许多多魑魅魍魉，他们面目狰狞地飞向这个世界，唱着狂欢的笙歌，去吞噬，去冻结，去撕扯这个世界。有一条小路在这轮孤月下面延伸，奔跑，不知道最终要去向的是哪个地方。小路旁边的有一盏灯火在暮色中亮起来。 透过那微弱的灯光，在窗户里面的一个圆桌子旁边围坐一家人，有个神情坚毅里透着憔悴的男人，有个体态瘦削却流露着母爱的女人，有个鼻子里流着鼻涕的小男孩正津津有味的吃着不知道是什么的东西。在小男孩的旁边有一只小狗欢快的摇着尾巴，看着小主人津津有味的吃着的东西，眼睛里有着自己绝对忠诚的小主人。 在这个有着一盏灯的小房子的后面，是一望无际的有着黄色土壤的田地。黑色的风绕过高山，掠过树梢，吹向了这片土地。 哗哗… 阵阵植物叶子簌簌地摩擦的声音，彼此起伏，蔓延开来。风掀起的黑色的叶子，呼啸着奔向对面的那片漆黑之中。 月亮渐渐地完全地被纯黑色的巨大黑幕所吞噬。 黑暗在世界任何一个角落里开着狂欢的派对。吸食着人们内心里最后的那么一点对于理想，自由，爱的追求。 恐慌，恐慌，满世界的恐慌。 黑暗，黑暗，满世界的黑暗。 在那个小屋子里的角落里，一个小男孩抱着一只懒洋洋的小狗甜甜地静静地在安睡。 那是一个美妙的梦，屋后面的那一望无际的植物终于开花了，在小男孩的爸爸妈妈付出了极其艰辛的劳动和汗水之后终于开花了。因为小男孩知道当这些个植物的开花的时候，肯定就是爸爸妈妈展开笑颜的时候了。 曾经很多个夜晚，小男孩对着夜空发呆，希望寻着一颗能够实现他愿望的星星。 在这个梦里，小男孩终于可以在花海奔跑，呵呵的笑声伴着小狗的汪汪叫声，在这片土地里延伸。 一群穿着黑色制服的人顺着那条小路向着这个黑暗里唯一的存在着微弱亮光的地方走来。 树影斑驳，人影可怖。 咚咚… 圆桌旁边男人，内心一惊，随后握紧了拳头。重重地压在桌子。旁边的妻子轻轻地把手放在男人的肩上。 “不要惊醒我的孩子，我们跟你们走！”。 吱吱… 门关上了。 四条人影在那条小道上前行，鞋子跟地面沙子摩擦的声音不时的响起，最后，最后，消失在远处的黑暗之中。 身后的那所小房子里，灯光依旧是那样地微弱。 只是，只是一个小男孩还有一个小狗依然静静地甜甜地睡着。 一夜的黑暗在太阳跳过对面山头的时候消失的无影无踪。 小男孩高兴地奔跑着去平时爸爸妈妈早上起来会去劳作的那片田地里，去告诉他们自己昨天做了一个美丽的梦。 时间渐渐过去了，小男孩有些心慌了，还不见爸爸妈妈。小狗在身后也嗷嗷地叫着，表示着不安。 小男孩疯狂地迈着小脚步在那片田地里穿梭。一朵朵美丽的花朵在他的眼前招摇，挡住了他寻找爸爸妈妈的视线。同时也淹没了小男孩小小身体。 黑夜渐渐地如梦魇般来到了。 在昨夜的那个小屋子里，再也没有了灯光。 哪怕是微弱的。 只是在那条路上站着一个小小男孩和一只小小狗。 在那条路上，小男孩决定去流浪，他没有眼泪，他不知掉为什么要流眼泪，为谁而流。小男孩反过身子，指着小狗，又指了一下与自己相对的另外与一个方向，狗狗很听话的把自己的头掉到了那个方向。 从此，便开始了两个生命体的流浪之旅。 两个身影消失在了夜色之中，只剩下那个小屋和午后的那片天地和田地里一望无际正开着花的植物。 匆匆的，时间流逝。那一个夜晚，那几个人物和故事，也归入到历史的洪流里，渐渐地渺小渺小，渺小到貌似不曾存在过。 一晃十几年过去了，过去了就是过去了。 后来的后来，有人看到了在那片山脚下，在那个曾经的小屋的后面的那片一望无际的田地里，每当植物开花的时候总有一个人影和一只狗游荡在那儿周围。他们的身影时隐实现在那一片罂粟花的海洋里。他们捍卫着在罂粟开花期的每一朵花，他们抵御了在罂粟花最美丽季节任何一个企图采摘哪怕一朵的破坏者。 一人一狗一片罂粟花。 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2016/09/27/tramp-and-poppy-flower/","categories":[{"name":"diary","slug":"diary","permalink":"https://zhangzhaoyu.github.io/categories/diary/"}],"tags":[{"name":"story","slug":"story","permalink":"https://zhangzhaoyu.github.io/tags/story/"}],"keywords":[{"name":"diary","slug":"diary","permalink":"https://zhangzhaoyu.github.io/categories/diary/"}]},{"title":"雲中的故事","slug":"story-of-the-cloud","date":"2015-05-03T04:12:12.000Z","updated":"2016-09-30T12:10:04.570Z","comments":true,"path":"2015/05/03/story-of-the-cloud/","link":"","permalink":"https://zhangzhaoyu.github.io/2015/05/03/story-of-the-cloud/","excerpt":"飄泊的那朵雲 心里藏着珠兒 一滴是姑娘的淚 一滴是男子的血 淚珠說：我是姑娘溫婉憂傷的情 血珠說：我是男子堅毅孤獨的心","text":"飄泊的那朵雲 心里藏着珠兒 一滴是姑娘的淚 一滴是男子的血 淚珠說：我是姑娘溫婉憂傷的情 血珠說：我是男子堅毅孤獨的心 驚雷一声 淚珠說：我怕 血珠說：你抱着我 她溶進他的心 他感覺自己的心變得好重好重 隨著風蕩 落在山中古寺的一片瓦上 朝日初升 寺中梵音唱起 那滴小雨 對着日和着梵音在瓦上 微笑着再見 本文章采用知识共享署名 2.5 中国大陆许可协议进行许可。欢迎转载，但转载请注明来自张兆玉，并保持转载后文章内容的完整。本人保留所有版权相关权利。本文链接：https://zhangzhaoyu.github.io/2015/05/03/story-of-the-cloud/","categories":[{"name":"diary","slug":"diary","permalink":"https://zhangzhaoyu.github.io/categories/diary/"}],"tags":[{"name":"story","slug":"story","permalink":"https://zhangzhaoyu.github.io/tags/story/"}],"keywords":[{"name":"diary","slug":"diary","permalink":"https://zhangzhaoyu.github.io/categories/diary/"}]}]}