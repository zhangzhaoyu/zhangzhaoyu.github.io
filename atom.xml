<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TRAMP 的博客</title>
  <subtitle>记录，仅仅为了记录那些</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangzhaoyu.github.io/"/>
  <updated>2016-11-18T15:26:42.467Z</updated>
  <id>https://zhangzhaoyu.github.io/</id>
  
  <author>
    <name>张兆玉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>寻根究底 Logging - SLF4J 日志Facade 概述</title>
    <link href="https://zhangzhaoyu.github.io/2016/11/18/spring-boot-logging-slf4j/"/>
    <id>https://zhangzhaoyu.github.io/2016/11/18/spring-boot-logging-slf4j/</id>
    <published>2016-11-18T13:50:01.000Z</published>
    <updated>2016-11-18T15:26:42.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SLF4J-概述"><a href="#SLF4J-概述" class="headerlink" title="SLF4J 概述"></a>SLF4J 概述</h1><p><code>SLF4J(Simple Logging Facade for Java)</code> 是一个抽象的Java 日志框架门面。它不关注日志的具体实现方法，会在<code>deployment time</code>自动的发现日志的实现类。目前SLF4J 支持的日志实现框架有<code>java.util.logging</code>，<code>logback</code> 和<code>log4j</code>。SLf4J 在运行时，仅仅只需要依赖<code>slf4j-api-1.7.21.jar</code>。</p>
<a id="more"></a>
<h1 id="SLF4J-详解"><a href="#SLF4J-详解" class="headerlink" title="SLF4J 详解"></a>SLF4J 详解</h1><h2 id="日志实现框架的切换机制"><a href="#日志实现框架的切换机制" class="headerlink" title="日志实现框架的切换机制"></a>日志实现框架的切换机制</h2><p>SLF4J 支持多种不同的日志实现框架。要实现各种日志实现框架的切换只需要在<code>classpath</code> 中包含对应的转换和实现JAR 包即可。如下图所示：<br><img src="concrete-bindings.png" alt="SLF4J 日志实现框架配置图"></p>
<ul>
<li><code>slf4j-simple-1.7.21.jar</code> : SLF4J 提供的日志简单的输出类，将把所有的错误信息输出到<code>System.err</code>，该实现方法在比较小的应用用比较实用</li>
<li><code>slf4j-log4j12-1.7.21.jar</code> : 绑定Log4j 的实现，还需要在<code>classpath</code> 中加入<code>log4j.jar</code></li>
<li><code>slf4j-jdk14-1.7.21.jar</code> : 绑定java.util.logging，需要JDK 1.4 以上</li>
<li><code>logback-classic-1.0.13.jar</code> : 绑定logback 实现，还需要加入<code>logback-core-1.0.13.jar</code>。logback 是默认实现SLF4J 的日志输出实现类。经作者测试性能要远远高于log4j</li>
<li><code>slf4j-jcl-1.7.21.jar</code> : 该绑定会将所有的SLF4J 代理到JCL(Jakarta Commons Logging)</li>
<li><code>slf4j-nop-1.7.21.jar</code> : 绑定为了NOP，所有的日志将不会被输出</li>
</ul>
<blockquote>
<p>需要注意的是不要同时在<code>classpath</code> 包含多个日志实现类。否则SLF4J 会报错。在SLF4J 1.6 之后的版本中，在<code>classpath</code> 没有绑定实现类，不会跑出错误，仅仅是警告提示。</p>
</blockquote>
<h2 id="MDC-支持"><a href="#MDC-支持" class="headerlink" title="MDC 支持"></a>MDC 支持</h2><p><code>MDC(Mapped Diagnostic Context)</code>基本上来说是一个由日志框架管理的<code>map</code> 对象。应用程序代码可以将<code>key-code</code> 存储在对象上。之后，日志框架可以取出MDC 中的数据，输出到日志信息中。如果日志实现框架支持MDC，SLF4J 将会代理对应的日志框架管理MDC。目前只有log4j 和 logback 支持。</p>
<h2 id="日志桥接"><a href="#日志桥接" class="headerlink" title="日志桥接"></a>日志桥接</h2><p>通常我们的应用程序会依赖不同的JAR 包，而不同的JAR 又由于各自的选择会有各种不同的日志实现框架。因此，如何在一个应用中来统一日志的输出形式，是一个需要解决的问题。SLF4J 提供了<code>Bridging legacy APIs</code> 来实现该功能。下图描述如在各种日志绑定实现框架下，如果做桥接的实现。<br>![SLF4J 日志桥接功能][legacy.png]</p>
<ul>
<li>JCL to SLF4J : 从Jakarta Commons Logging 桥接到SLF4J 需要使用<code>jcl-over-slf4j.jar</code>。它实现了JCL 的公共的API 接口，但是底部却是调用的SLF4J。由它替换到<code>commons-logging.jar</code>。同时可以解决commons logging 的classloader 问题。<code>jcl-over-slf4j.jar</code> 不能跟 <code>slf4j-jcl.jar</code> 同时使用。</li>
<li>log4j-over-slf4j : 不改变一行代码的情况下，将log4j 桥接到slf4j。仅仅需要使用<code>log4j-over-slf4j.jar</code>替换<code>log4j.jar</code>。<code>log4j-over-slf4j.jar</code>和<code>slf4j-log4j12.jar</code> 不能同时出现。</li>
<li>jul-to-slf4j : 将java.util.logging 桥接到slf4j。<code>ul-to-slf4j.jar</code>和<code>slf4j-jdk14.jar</code>不能同时出现。</li>
</ul>
<h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><ol>
<li><a href="http://www.slf4j.org/manual.html" target="_blank" rel="external">SLF4J Manual</a></li>
<li><a href="http://www.slf4j.org/legacy.html" target="_blank" rel="external">Bridging legacy APIs</a></li>
</ol>
<hr>
<p>本文章采用<a href="https://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可。<br>欢迎转载，但转载请注明来自<a href="https://zhangzhaoyu.github.io/">张兆玉</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文链接：<a href="https://zhangzhaoyu.github.io/2016/11/18/spring-boot-logging-slf4j/">https://zhangzhaoyu.github.io/2016/11/18/spring-boot-logging-slf4j/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SLF4J-概述&quot;&gt;&lt;a href=&quot;#SLF4J-概述&quot; class=&quot;headerlink&quot; title=&quot;SLF4J 概述&quot;&gt;&lt;/a&gt;SLF4J 概述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;SLF4J(Simple Logging Facade for Java)&lt;/code&gt; 是一个抽象的Java 日志框架门面。它不关注日志的具体实现方法，会在&lt;code&gt;deployment time&lt;/code&gt;自动的发现日志的实现类。目前SLF4J 支持的日志实现框架有&lt;code&gt;java.util.logging&lt;/code&gt;，&lt;code&gt;logback&lt;/code&gt; 和&lt;code&gt;log4j&lt;/code&gt;。SLf4J 在运行时，仅仅只需要依赖&lt;code&gt;slf4j-api-1.7.21.jar&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="https://zhangzhaoyu.github.io/categories/Spring-Boot/"/>
    
    
      <category term="SLF4J" scheme="https://zhangzhaoyu.github.io/tags/SLF4J/"/>
    
  </entry>
  
  <entry>
    <title>寻根究底 Logging - Spring Boot 日志概述</title>
    <link href="https://zhangzhaoyu.github.io/2016/11/16/spring-boot-logging-introduction/"/>
    <id>https://zhangzhaoyu.github.io/2016/11/16/spring-boot-logging-introduction/</id>
    <published>2016-11-16T14:07:26.000Z</published>
    <updated>2016-11-18T14:56:17.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-日志概述"><a href="#Spring-Boot-日志概述" class="headerlink" title="Spring Boot 日志概述"></a>Spring Boot 日志概述</h1><p>Spring Boot 采用 <code>Commons Logging</code> 作为内部的日志框架。对于日志的具体实现，则没有限制。默认的提供了对<code>Java Util Logging</code>，<code>Log4J2</code> 和 <code>Logback</code> 的支持。每种方式下，<code>Console</code> 的日志输出，作为默认的日志输出。<br>在默认情况下，采用<code>Starters</code> 来启动Spring Boot 项目，<code>Logback</code> 是默认的日志实现方案。当然，Logback 路由能够保证依赖的包使用的其他日志也可以很好的工作。<br><a id="more"></a></p>
<h1 id="默认日志"><a href="#默认日志" class="headerlink" title="默认日志"></a>默认日志</h1><h2 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h2><p>默认的日志格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2014-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52</div><div class="line">2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]</div></pre></td></tr></table></figure>
<p>具体的含义如下：</p>
<ul>
<li>精确到毫秒的日期和时间</li>
<li>Log Level - <code>ERROR</code>，<code>WARN</code>，<code>INFO</code> 或者 <code>TRACE</code></li>
<li>进程ID</li>
<li><code>---</code> 具体的日志内容的分隔符</li>
<li>线程名字</li>
<li>Logger Name - 通常是定义日志记录的类名</li>
<li>具体的日志内容</li>
</ul>
<blockquote>
<p>需要注意的是Logback 没有 <code>FATAL</code> 的日志级别，它被映射到<code>ERROR</code></p>
</blockquote>
<h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><p>默认的日志配置会将ERROR，WARN 和 INFO级别的日志输出到控制台。我们也可以使用”DEBUG” 模式才输出更多的内容。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ java -jar myapp.jar --debug</div></pre></td></tr></table></figure></p>
<p>也可以在Spring Boot的配置文件<code>application.properties</code> 中配置<code>debug=true</code> 来开启更多的日志输出功能。此模式只能输出被选择的核心logger 来输出更多的消息，例如内嵌的容器，Hibernate 和spring Boot。我们自己的应用并不会输出Debug 级别的日志。另外同上我们也可以配置<code>trace</code> 模式来输出更多的日志内容，但也只是一个被选择的核心Logger 列表。</p>
<h2 id="Color-coded-输出"><a href="#Color-coded-输出" class="headerlink" title="Color-coded 输出"></a>Color-coded 输出</h2><p>如果终端支持<code>ANSI</code>，将会输出彩色的日志。可以再<code>application.properties</code> 文件中设置<code>spring.output.ansi.enabled</code> 为<code>always</code>，<code>detect</code> 和<code>never</code> 来覆盖默认的级别，默认为<code>detect</code>。<br>彩色的样式采用<code>%clr</code> 来进行转换。最简单的模式就是日志将根据Level 输出为不同的颜色:</p>
<ul>
<li>FATAL : Red</li>
<li>ERROR : Red</li>
<li>WARN : Yellow</li>
<li>INFO : Green</li>
<li>DEBUG : Green</li>
<li>TRACE : Green</li>
</ul>
<p>除此之外，可以指定转换日志时的颜色，通过指定转换选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;option&#125;</div></pre></td></tr></table></figure></p>
<p><code>option</code> 可以指定为：</p>
<ul>
<li>blue</li>
<li>cyan</li>
<li>faint</li>
<li>green</li>
<li>magenta</li>
<li>red</li>
<li>yellow</li>
</ul>
<h2 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h2><p>默认情况下，Spring Boot 仅仅将日志输出在控制台。如果需要将日志输出到文件需要在<code>application.properties</code> 中配置<code>logging.file</code> 或者 <code>logging.path</code>。</p>
<ul>
<li>logging.file : 输出到指定的文件，可以为相对路径或者绝对路径</li>
<li>logging.path : 与logging.file 是互斥的，指定文件的路径，默认的文件名为<code>spring.log</code></li>
</ul>
<p>日志文件默认达到10Mb 时，将会从新打开一个文件输出，默认的日志输出级别为ERROR，WARN 和 INFO。需要注意的是日志系统的初始化要早于系统的生命周期，因此logging properties 不能够通过@PropertySource 注解获取。</p>
<p>Logging properties 相对于实际的日志框架是独立的，因此特定的日志的配置参数并不归Spring Boot 管理。</p>
<h2 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h2><p>所有支持的日志系统都可以通过<code>logging.level.*</code>=LEVEL 在<code>application.properties</code> 中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">logging.level.root=WARN</div><div class="line">logging.level.org.springframework.web=DEBUG</div><div class="line">logging.level.org.hibernate=ERROR</div></pre></td></tr></table></figure>
<p>默认条件下，Spring Boot 重新映射了Thymeleaf 的INFO 级别日志到DEBUG 级别。具体可以参见<code>LevelRemappingAppender</code> 类的细节。</p>
<h1 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h1><h2 id="配置概述"><a href="#配置概述" class="headerlink" title="配置概述"></a>配置概述</h2><p>通过将不同的日志依赖包添加到<code>classpath</code> 中，Spring Boot 的日志系统能够判断激活不同的日志实现方式。更进一步的配置是将自定义的日志配置文件添加到<code>classpath</code> 中，或者通过Spring 的<code>logging.config</code> 来指定配置文件的位置。</p>
<p>可以通过设置<code>org.springframework.boot.logging.LoggingSystem</code> 系统变量来配置一个特殊的日志系统。对应的设置值应该是<code>LoggingSystem</code> 的实现类。也可以将该变量的值设置为<code>none</code> 来关闭Spring Boot 的日志。</p>
<p>由于日志的初始化早于<code>ApplicationContext</code> 的创建，因此不能够通过<code>@Configuration</code> 文件来进行配置。只能通过系统变量或者外部的传统配置文件来进行配置。</p>
<h2 id="自定义配置文件加载"><a href="#自定义配置文件加载" class="headerlink" title="自定义配置文件加载"></a>自定义配置文件加载</h2><ul>
<li><strong>Logback</strong> : logback-spring.xml, logback-spring.groovy, logback.xml 或者logback.groovy</li>
<li><strong>Log4j2</strong> : log4j2-spring.xml 或者　log4j2.xml</li>
<li><strong>JDK(Java Util Logging)</strong> : logging.properties</li>
</ul>
<blockquote>
<p>需要注意的是官方推荐使用<code>-spring</code> 的配置方式。如果使用标准的配置方式，Spring 不能完全控制日志的初始化。此外，当采用<code>executable jar</code> 方式时，Java Util Logging 会产生已知的错误，因此要避免使用。</p>
</blockquote>
<h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>为了帮助实现自定义，以下的Spring Environment 变量会被转化为系统变量</p>
<ul>
<li><code>logging.exception-conversion-word</code> : <code>LOG_EXCEPTION_CONVERSION_WORD</code> : 日志异常时的转换语</li>
<li><code>logging.file</code> : <code>LOG_FILE</code> : 默认的日志文件路径和名称配置</li>
<li><code>logging.path</code> : <code>LOG_PATH</code> : 默认的日志路径配置</li>
<li><code>logging.pattern.console</code> : <code>CONSOLE_LOG_PATTERN</code> : 控制台日志的格式，只支持logback</li>
<li><code>logging.pattern.file</code> : <code>FILE_LOG_PATTERN</code> : 日志文件中日志的格式，只支持logback</li>
<li><code>logging.pattern.level</code> : <code>LOG_LEVEL_PATTERN</code> : 日志等级的格式渲染，只支持logback</li>
<li><code>PID</code> : <code>PID</code> : 当前进程的ID</li>
</ul>
<p>如果想要在日志属性中使用占位符，需要使用<a href="http://docs.spring.io/spring-boot/docs/1.4.2.RELEASE/reference/htmlsingle/#boot-features-external-config-placeholders-in-properties" target="_blank" rel="external">Spring Boot syntax</a> 而不是对应日志框架的语法。例如Logback 的属性名之间的分隔符为<code>:</code>，而不是其自身默认的<code>:-</code>。</p>
<h2 id="Logback-扩展"><a href="#Logback-扩展" class="headerlink" title="Logback 扩展"></a>Logback 扩展</h2><p>为了实现Spring 对logback 的扩展，我们需要将logback 的配置文件的名字定义为<code>logback-spring.xml</code>，或者采用<code>logging.config</code> 来指定配置文件的位置。</p>
<p>Spring Boot 可以采用<code>&lt;springProfile&gt;</code> 标签来激活不同的Spring Profile 配置。Profile 片段可以定义在<code>&lt;configuration&gt;</code> 元素的任何位置。可以使用<code>name</code> 属性来指明需要接受的profile 类型。可以用<code>,</code> 来指定多个profile。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev, staging"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- configuration to be enabled when the "dev" or "staging" profiles are active --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!production"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- configuration to be enabled when the "production" profile is not active --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>Spring Boot 也可以采用<code>&lt;springProperty&gt;</code> 标签来获取在Spring Environment 中定义的属性。也就是说可以在logback 配置文件中获取在<code>application.properties</code> 中定义的变量。通常它也能直接工作在logbak 的<code>&lt;property&gt;</code> 标签中。具体配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">"context"</span> <span class="attr">name</span>=<span class="string">"fluentHost"</span> <span class="attr">source</span>=<span class="string">"myapp.fluentd.host"</span></span></div><div class="line">        <span class="attr">defaultValue</span>=<span class="string">"localhost"</span>/&gt;</div><div class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FLUENT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.more.appenders.DataFluentAppender"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">remoteHost</span>&gt;</span>$&#123;fluentHost&#125;<span class="tag">&lt;/<span class="name">remoteHost</span>&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>此处采用的是<code>RelaxedPropertyResolver</code> 来获取Spring Environment 变量，因此在定义source的时候的变量采用虚线连接时，对应的变量可以松散的匹配。比如<code>my-property-name</code> 将会匹配<code>myPropertyName</code> 和<code>MY_PROPERTY_NAME</code>。</p>
<h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><ol>
<li><a href="http://docs.spring.io/spring-boot/docs/1.4.2.RELEASE/reference/htmlsingle/#boot-features-logging" target="_blank" rel="external">Spring Boot Logging</a></li>
</ol>
<hr>
<p>本文章采用<a href="https://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可。<br>欢迎转载，但转载请注明来自<a href="https://zhangzhaoyu.github.io/">张兆玉</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文链接：<a href="https://zhangzhaoyu.github.io/2016/11/16/spring-boot-logging-introduction/">https://zhangzhaoyu.github.io/2016/11/16/spring-boot-logging-introduction/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-Boot-日志概述&quot;&gt;&lt;a href=&quot;#Spring-Boot-日志概述&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 日志概述&quot;&gt;&lt;/a&gt;Spring Boot 日志概述&lt;/h1&gt;&lt;p&gt;Spring Boot 采用 &lt;code&gt;Commons Logging&lt;/code&gt; 作为内部的日志框架。对于日志的具体实现，则没有限制。默认的提供了对&lt;code&gt;Java Util Logging&lt;/code&gt;，&lt;code&gt;Log4J2&lt;/code&gt; 和 &lt;code&gt;Logback&lt;/code&gt; 的支持。每种方式下，&lt;code&gt;Console&lt;/code&gt; 的日志输出，作为默认的日志输出。&lt;br&gt;在默认情况下，采用&lt;code&gt;Starters&lt;/code&gt; 来启动Spring Boot 项目，&lt;code&gt;Logback&lt;/code&gt; 是默认的日志实现方案。当然，Logback 路由能够保证依赖的包使用的其他日志也可以很好的工作。&lt;br&gt;
    
    </summary>
    
      <category term="Spring Boot" scheme="https://zhangzhaoyu.github.io/categories/Spring-Boot/"/>
    
    
      <category term="-logging" scheme="https://zhangzhaoyu.github.io/tags/logging/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ 寻根究低 - 点对点模式详解</title>
    <link href="https://zhangzhaoyu.github.io/2016/10/21/jms-activemq-queue-md/"/>
    <id>https://zhangzhaoyu.github.io/2016/10/21/jms-activemq-queue-md/</id>
    <published>2016-10-21T06:52:32.000Z</published>
    <updated>2016-10-24T05:09:47.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文在<a href="2016/10/19/jms-specification-introduction/">ActiveMQ 寻根究低 - JMS 规范概述</a>一问的基础上，探究点对点模式的具体变成实现方案，以及点对点模式在实际应用的的具体场景。<br><a id="more"></a></p>
<h1 id="JMS-程序设计模式"><a href="#JMS-程序设计模式" class="headerlink" title="JMS 程序设计模式"></a>JMS 程序设计模式</h1><p>JMS 程序的模式主要是给予PTP 和 Pub/Sub 配置一些参数的不同来应用到不同的场景中。根据具体的业务对性能、对数据的安全性等再进行最终方案的选型。通用的结构如下图:<br><img src="jmsmodel.png" alt="JMS 程序设计的结构"></p>
<h1 id="点对点-PTP-模式的实现"><a href="#点对点-PTP-模式的实现" class="headerlink" title="点对点(PTP)模式的实现"></a>点对点(PTP)模式的实现</h1><h2 id="几个通用类"><a href="#几个通用类" class="headerlink" title="几个通用类"></a>几个通用类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConnectionFactory <span class="title">getConnectionFactory</span><span class="params">()</span> </span>&#123;</div><div class="line">        ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(</div><div class="line">                ActiveMQConnectionFactory.DEFAULT_USER,</div><div class="line">                ActiveMQConnectionFactory.DEFAULT_PASSWORD,</div><div class="line">                ActiveMQConnectionFactory.DEFAULT_BROKER_URL</div><div class="line">        );</div><div class="line">        <span class="keyword">return</span> connectionFactory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Session session, Connection connection)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                session.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">                <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        connection.close();</div><div class="line">                    &#125; <span class="keyword">catch</span> (JMSException e1) &#123;</div><div class="line">                        e1.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                connection.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(MessageProducer producer, Session session, Connection connection)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (producer != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                producer.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">               close(session, connection);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        close(session, connection);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(MessageConsumer consumer, Session session, Connection connection)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                consumer.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">                close(session, connection);</div><div class="line">            &#125;</div><div class="line">            close(session, connection);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Obj implements Serializable &#123;</div><div class="line">    int age;</div><div class="line">    String name;</div><div class="line"></div><div class="line">    public Obj() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Obj(int age, String name) &#123;</div><div class="line">        this.age = age;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return new ToStringBuilder(this)</div><div class="line">                .append(&quot;age&quot;, age)</div><div class="line">                .append(&quot;name&quot;, name)</div><div class="line">                .toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="PTP-模式生产者"><a href="#PTP-模式生产者" class="headerlink" title="PTP 模式生产者"></a>PTP 模式生产者</h2><h3 id="非事务方式的生产者"><a href="#非事务方式的生产者" class="headerlink" title="非事务方式的生产者"></a>非事务方式的生产者</h3><p>非事务的生产者需要将<code>connection.createSession(transacted, acknowledge)</code> 的第一个参数设置为<code>FALSE</code>。第二个参数指明的消息接受者的应答方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PTPSyncQueueProducer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOG = LoggerFactory.getLogger(PTPSyncQueueProducer.class);</div><div class="line">    Connection connection;</div><div class="line">    Session session;</div><div class="line">    Destination destination;</div><div class="line">    MessageProducer messageProducer;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                connection = ConnectionUtils.getConnectionFactory().createConnection();</div><div class="line">                connection.start();</div><div class="line">                <span class="comment">// first param is transacted</span></div><div class="line">                session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);</div><div class="line">                destination = session.createQueue(<span class="string">"PTPSyncQueueProducer"</span>);</div><div class="line">                messageProducer = session.createProducer(destination);</div><div class="line">                ObjectMessage objectMessage = session.createObjectMessage();</div><div class="line">                objectMessage.setObject(<span class="keyword">new</span> Obj(++i, <span class="string">"littler Bai"</span>));</div><div class="line"></div><div class="line">                messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</div><div class="line">                messageProducer.setPriority(Message.DEFAULT_PRIORITY);</div><div class="line">                messageProducer.setTimeToLive(Message.DEFAULT_TIME_TO_LIVE);</div><div class="line"></div><div class="line">                messageProducer.send(objectMessage);</div><div class="line">                LOG.info(<span class="string">"send &#123;&#125;"</span>, i);</div><div class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">                ConnectionUtils.close(messageProducer, session, connection);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="基于事务的生成者"><a href="#基于事务的生成者" class="headerlink" title="基于事务的生成者"></a>基于事务的生成者</h3><p>基于事务的生产者。只有再事务提交时，消息才已打包的方式一起发送到JMS Provider。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transactedProducer</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connection = ConnectionUtils.getConnectionFactory().createConnection();</div><div class="line">            connection.start();</div><div class="line">            <span class="comment">// first param is transacted,if true transaction</span></div><div class="line">            session = connection.createSession(Boolean.TRUE, Session.AUTO_ACKNOWLEDGE);</div><div class="line">            destination = session.createQueue(<span class="string">"PTPSyncQueueProducer"</span>);</div><div class="line">            messageProducer = session.createProducer(destination);</div><div class="line"></div><div class="line">            messageProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</div><div class="line">            messageProducer.setPriority(Message.DEFAULT_PRIORITY);</div><div class="line">            messageProducer.setTimeToLive(Message.DEFAULT_TIME_TO_LIVE);</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">                ObjectMessage objectMessage = session.createObjectMessage();</div><div class="line">                objectMessage.setObject(<span class="keyword">new</span> Obj(i, <span class="string">"littler Bai"</span>));</div><div class="line">                messageProducer.send(objectMessage);</div><div class="line">                LOG.info(<span class="string">"send &#123;&#125;"</span>, i);</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"begin sleep"</span>);</div><div class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</div><div class="line">            session.commit();</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                session.rollback();</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException ex) &#123;</div><div class="line">                ex.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            ConnectionUtils.close(messageProducer, session, connection);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="PTP-模式消费者"><a href="#PTP-模式消费者" class="headerlink" title="PTP 模式消费者"></a>PTP 模式消费者</h2><h3 id="基于阻塞的消费者"><a href="#基于阻塞的消费者" class="headerlink" title="基于阻塞的消费者"></a>基于阻塞的消费者</h3><p>基于阻塞的消费者采用<code>MessageConsumer.receive(timeout)</code> 方法来阻塞当前线程，循环获取监测的<code>Destination</code> 的消息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PTPQueueCustomer</span> </span>&#123;</div><div class="line">    Connection connection;</div><div class="line">    Session session;</div><div class="line">    Destination destination;</div><div class="line">    MessageConsumer messageConsumer;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connection = ConnectionUtils.getConnectionFactory().createConnection();</div><div class="line">            connection.start();</div><div class="line">            session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);</div><div class="line">            destination = session.createQueue(<span class="string">"PTPSyncQueueProducer"</span>);</div><div class="line">            messageConsumer = session.createConsumer(destination);</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                Message message = messageConsumer.receive(<span class="number">1000</span>);</div><div class="line">                <span class="keyword">if</span> (message <span class="keyword">instanceof</span> ObjectMessage) &#123;</div><div class="line">                    ObjectMessage objectMessage = (ObjectMessage) message;</div><div class="line">                    System.out.println(objectMessage.getObject());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            ConnectionUtils.close(messageConsumer, session, connection);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//new PTPQueueCustomer().consume();</span></div><div class="line">        <span class="keyword">new</span> PTPQueueCustomer().asyncConsume();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="基于MessageListener-的异步消费者"><a href="#基于MessageListener-的异步消费者" class="headerlink" title="基于MessageListener 的异步消费者"></a>基于MessageListener 的异步消费者</h3><p>基于<code>MessageListener</code> 的异步消费者需要实现该接口，并在<code>MessageConsumer.setMessageListener(listener)</code> 方法上注册。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> ObjectMessage) &#123;</div><div class="line">            ObjectMessage objectMessage = (ObjectMessage) message;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(objectMessage.getObject());</div><div class="line">            &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncConsume</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            connection = ConnectionUtils.getConnectionFactory().createConnection();</div><div class="line">            connection.start();</div><div class="line">            session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);</div><div class="line">            destination = session.createQueue(<span class="string">"PTPSyncQueueProducer"</span>);</div><div class="line">            messageConsumer = session.createConsumer(destination);</div><div class="line"></div><div class="line">            messageConsumer.setMessageListener(<span class="keyword">new</span> QueueMessageListener());</div><div class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然PTP 模式，规定了一个消息（<code>Message</code>）只能由一个消费者消费，但是并不意味着一个PTP 的<code>Destination</code> 只能连接一个消费者。因此，PTP 模式典型应用由：</p>
<ul>
<li>应用到将同一件事情分散到多个处理者。</li>
<li>订单处理系统，如定时抢购，银行纪念币抢兑</li>
<li>一对一系统间调用的解耦</li>
<li>基于PTP 实现<code>request-response</code> 应答模式</li>
</ul>
<h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><ol>
<li><a href="2016/10/19/jms-specification-introduction/">ActiveMQ 寻根究低 - JMS 规范概述</a></li>
</ol>
<hr>
<p>本文章采用<a href="https://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可。<br>欢迎转载，但转载请注明来自<a href="https://zhangzhaoyu.github.io/">张兆玉</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文链接：<a href="https://zhangzhaoyu.github.io/2016/10/21/jms-activemq-queue-md/">https://zhangzhaoyu.github.io/2016/10/21/jms-activemq-queue-md/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本文在&lt;a href=&quot;2016/10/19/jms-specification-introduction/&quot;&gt;ActiveMQ 寻根究低 - JMS 规范概述&lt;/a&gt;一问的基础上，探究点对点模式的具体变成实现方案，以及点对点模式在实际应用的的具体场景。&lt;br&gt;
    
    </summary>
    
      <category term="ActiveMQ" scheme="https://zhangzhaoyu.github.io/categories/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="https://zhangzhaoyu.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ 寻根究低 - JMS 规范概述</title>
    <link href="https://zhangzhaoyu.github.io/2016/10/19/jms-specification-introduction/"/>
    <id>https://zhangzhaoyu.github.io/2016/10/19/jms-specification-introduction/</id>
    <published>2016-10-19T06:55:02.000Z</published>
    <updated>2016-10-21T04:37:17.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JMS-概述"><a href="#JMS-概述" class="headerlink" title="JMS 概述"></a>JMS 概述</h1><p>JMS1.1（Java Message Service）是Java 推出的访问已存在的消息产品的一种标准规范，也被称为消息中间件。 JMS 为Java 语言的客户端和Java 语言的中间曾服务使用这些消息系统提供了一种通用的方法。它主要是定义了消息语义，以及一组与之对应的Java 接口。JMS的规范包容了对Java 编程语言之外的其他语言的支持。</p>
<a id="more"></a>
<h1 id="JMS-的两种类型"><a href="#JMS-的两种类型" class="headerlink" title="JMS 的两种类型"></a>JMS 的两种类型</h1><h2 id="点对点（P2P）"><a href="#点对点（P2P）" class="headerlink" title="点对点（P2P）"></a>点对点（P2P）</h2><p>点对点系统与消息队列一起工作的。大多数队列由管理员创建，并被客户端看做是静态资源。<br><img src="ptp.png" alt="点对点结构图"></p>
<h2 id="发布-订阅（Pub-Sub）"><a href="#发布-订阅（Pub-Sub）" class="headerlink" title="发布/订阅（Pub/Sub）"></a>发布/订阅（Pub/Sub）</h2><p>JMS Pub/Sub 模型定义了客户端如何发布消息到给予内容层次的众所周知的节点和如何从节点订阅消息。<br><img src="pubsub.png" alt="发布/订阅结构图"></p>
<h1 id="JMS-消息"><a href="#JMS-消息" class="headerlink" title="JMS 消息"></a>JMS 消息</h1><p>消息（Message）在JMS 中被用来描述企业应用间的异步通信。包括异步请求、响应或事件，它们是被企业应用消费的。JMS 消息有以下基本分组成：</p>
<ul>
<li>消息头 所有的消息都值相同的头字段集。头字段办函了客户端和提供商都要使用的用于标识和路由消息的值。</li>
<li>属性 除了标准的头字段外，消息提供了一个内置的功能来向消息增加可选的头字段。<ul>
<li>应用专有属性 为消息增加应用专有的头字段提供的机制。</li>
<li>标准属性 JMS 定义的一些标准属性，他们相当于可选的头字段。</li>
<li>提供上专有属性 提供商专有的属性。</li>
</ul>
</li>
<li>消息体 JMS 定义了几个消息体类型。这些类型覆盖了大部分当前使用的消息风格。</li>
</ul>
<h2 id="消息字段头"><a href="#消息字段头" class="headerlink" title="消息字段头"></a>消息字段头</h2><ul>
<li>JMSDestination 包含了消息被发往的目的地。创建消息时可以设置JMSDestination，但是消息发送完毕时，会被更新为发送方指定的JMSDetination。</li>
<li>JMSDeliveryMode 包含了消息发送时指定的转发模式。<ul>
<li>NON_PERSISTENT 最多一次的。消息会因JMS Provider 的停止而丢失。</li>
<li>PERSISTENT 有且只有一次。JMS Provider 服务停止重启后不会丢失。</li>
</ul>
</li>
<li>JMSMessageID 包含了一个用于唯一标识由JMS provider发送的每个消息。</li>
<li>JMSTimestamp 包含了消息被发送的时间。但不是消息被真正转发的时间。</li>
<li>JMSCorrelation 客户端可以使用JMSCorrelationID 来链接消息，典型的用法就是将响应消息和请求消息连接起来。</li>
<li>JMSReplyTo 消息被发送时包含一个由客户端支持的目的地。它是回复消息应当被发送的目的地。</li>
<li>JMSRedelivered 当消费者收到带有 JMSRedelivered 的消息头时，表明该消息在过去传输过但没有被确认。JMS Provider 必须对该字段进行设置，当为 true 时即告知消费者该消息是重传的，消费者需要自行处理重复的消息。</li>
<li>JMSType 包含了由客户端在发送消息时指定的消息类型标识。</li>
<li>JMSExpiration 消息的过期时间，其值为当前时间加上存活时间（毫秒）；当存活时间设置为 0 时，该字段的值也被设置为 0 ，表示永不过期。</li>
<li>JMSPriority 包含了消息的优先级。消息的优先级， 0 代表最低优先级， 9 代表最高优先级；一般 0~4 为普通优先级， 5~9 为加快优先级。</li>
</ul>
<h2 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h2><p>Message 除了定义的头字段外，还有一个内置的功能，就是支持为该消息添加可选头字段。例如<em>setObjectProperty()</em> 等方法。</p>
<h2 id="消息体的格式"><a href="#消息体的格式" class="headerlink" title="消息体的格式"></a>消息体的格式</h2><ul>
<li><code>SteamMessage</code> 消息体包含的是Java 的原始流，它连续的填充和读。</li>
<li><code>MapMessage</code> 消息体包含一系列的键值对。键值的顺序没有定义。</li>
<li><code>TextMessage</code> 消息体包含的是java.lang.String。</li>
<li><code>ObjectMessage</code> 消息体包含了可序列化的Java 对象。也可以是对象集合。</li>
<li><code>BytesMessage</code> 消息包含一个未解释的字节流。</li>
</ul>
<h2 id="消息的确认"><a href="#消息的确认" class="headerlink" title="消息的确认"></a>消息的确认</h2><p>如果会话是事务性的，那么消息确认自动由commit 处理，切恢复由rollcack 处理。非事物的方式如下：</p>
<ul>
<li><code>DUPS_OK_ACKNOWLEDGE</code> 该选项称为懒惰的消息传递。该选项只用于可以忍受重复消息的消费者。</li>
<li><code>AUTO_ACKNOWLEDGE</code> 当消息被成功地从调用接收返回或MessageListener 成功返回时，会话自动确认刻画段的消息接收。</li>
<li><code>CLIENT_ACKNOWLEDGE</code> 客户端通过调用消息的acknowledge 方法来确认消息。确认一个被消费的消息会自动确认被该会话转发的所有消息。</li>
</ul>
<h2 id="受管对象"><a href="#受管对象" class="headerlink" title="受管对象"></a>受管对象</h2><p>JMS 的受管对象是那些包含了JMS 配置信息的对象。这些配置信息通常由管理员配置然后由客户端使用。JMS 的受管对象可以通过JNDI 查找。</p>
<ul>
<li>Destination 包含了除地址外的提供商特有的配置信息且它支持并发使用。代表了一个打开的TCP/IP Scoket 连接。<ul>
<li>它再授权发生的地方创建</li>
<li>它能定义一个独一无二的ClientID</li>
<li>它能够创建Session</li>
<li>它提供连接的元信息，ConnectionMetaData</li>
<li>它支持一个可选的ExceptionListener</li>
</ul>
</li>
<li>ConnectionFactory 封装了一系列的提供商的连接配置参数，Client 使用它来创建与JMS Provider 的连接。同时，其支持并发。</li>
</ul>
<h2 id="常用对象"><a href="#常用对象" class="headerlink" title="常用对象"></a>常用对象</h2><ul>
<li>Connection 表示客户端和JMS 系统之间的连接。Connection 可以产生一个或多个Session。</li>
<li>Session 通过session 创建生产者、消费者和消息等。Session 也提供了事务的功能。</li>
<li>TemporaryQueue和TemporaryTopic 临时目的地通常用作JMSReplayTo 的目的地。</li>
<li>QueueBrower 用来查看队列中的消息，但不删除它们。</li>
<li>QueueRequestor 来简化服务请求，提供一个request 方法来发送请求信息和等待回复。</li>
<li>MessageListener 异步的模式，消息的监听者。一旦注册，消息到达时，就会通知。</li>
<li>ExceptionListener 处理连接的异常信息的地方。</li>
</ul>
<h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><ol>
<li><a href="https://jcp.org/en/jsr/detail?id=914" target="_blank" rel="external">JMS 1.1 规范</a></li>
</ol>
<hr>
<p>本文章采用<a href="https://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可。<br>欢迎转载，但转载请注明来自<a href="https://zhangzhaoyu.github.io/">张兆玉</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文链接：<a href="https://zhangzhaoyu.github.io/2016/10/19/jms-specification-introduction/">https://zhangzhaoyu.github.io/2016/10/19/jms-specification-introduction/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JMS-概述&quot;&gt;&lt;a href=&quot;#JMS-概述&quot; class=&quot;headerlink&quot; title=&quot;JMS 概述&quot;&gt;&lt;/a&gt;JMS 概述&lt;/h1&gt;&lt;p&gt;JMS1.1（Java Message Service）是Java 推出的访问已存在的消息产品的一种标准规范，也被称为消息中间件。 JMS 为Java 语言的客户端和Java 语言的中间曾服务使用这些消息系统提供了一种通用的方法。它主要是定义了消息语义，以及一组与之对应的Java 接口。JMS的规范包容了对Java 编程语言之外的其他语言的支持。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ActiveMQ" scheme="https://zhangzhaoyu.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>设计模式寻根究底 - 单例模式(Singleton Pattern)</title>
    <link href="https://zhangzhaoyu.github.io/2016/10/08/introduction-of-singleton-design-pattern/"/>
    <id>https://zhangzhaoyu.github.io/2016/10/08/introduction-of-singleton-design-pattern/</id>
    <published>2016-10-08T04:22:45.000Z</published>
    <updated>2016-11-18T13:25:21.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>单例模式是一个既简单又复杂的模式。简单在它想实现的目标十分容易理解，而又复杂在要写出线程安全的单例模式不是那么容易。单例模式的核心定义是：确保某个类只有一个实例，并提供一个访问该实例的全局访问点(Ensure a class has only instance, and provide a global point of access to it)。</p>
<a id="more"></a>
<h1 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h1><p>单例模式的实现分为急切的（Eager）和延迟的(Lazy)，线程安全(Thread-Safe)和非线程安全(Non-Thread-Safe)几种。下面就Java 对单例模式的实现进行介绍。</p>
<h2 id="Eager-模式实现"><a href="#Eager-模式实现" class="headerlink" title="Eager 模式实现"></a>Eager 模式实现</h2><p>Eager 模式的实现通常在静态的单例字段声明时（或单例类的构造函数）就创建该单例的对象。这样在单例类被Java 虚拟机加载时，就能够实例化该单例。</p>
<h3 id="基于静态域的Eager-模式"><a href="#基于静态域的Eager-模式" class="headerlink" title="基于静态域的Eager 模式"></a>基于静态域的Eager 模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StaticSingleton INSTANCE = <span class="keyword">new</span> StaticSingleton();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticSingleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 解决反序列化出现多个实例的问题</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将初始化放到静态块中实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> Singleton instance = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">static</span> &#123;  </div><div class="line">        instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="基Java-Enum-实现的Eager-模式"><a href="#基Java-Enum-实现的Eager-模式" class="headerlink" title="基Java Enum 实现的Eager 模式"></a>基<strong>Java Enum</strong> 实现的Eager 模式</h3><p>Java 枚举模式实现的单例是被推崇的，因为其具有：</p>
<ul>
<li>绝对的线程安全的，由Java 虚拟机保证</li>
<li>不会因为反序列化产生对个实例，Enum 在底层实现了<em>readResolve()</em> 方法</li>
<li>由于Enum 类型在Java 底层是由<strong>abstract</strong> 修饰的类，因此没法被实例化，能够防止反射攻击。因为反射机制可以调用私有的构造器构造对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  EnumSingleton &#123;</div><div class="line">    INSTANCE;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Object singleton;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello : "</span> + name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">        singleton = <span class="keyword">new</span> Object();</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        EnumSingleton.INSTANCE.print(<span class="string">"hello"</span>);</div><div class="line">        Object object = EnumSingleton.INSTANCE.build();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Lazy-模式实现"><a href="#Lazy-模式实现" class="headerlink" title="Lazy 模式实现"></a>Lazy 模式实现</h2><p>Eager 模式的实现可以避免线程的问题，但是当单例对象需要加载的系统资源很多时，会导致系统在启动时很慢。因此，需要一种方式在使用该对象时构造。也就是单例实现的Lazy 模式。</p>
<h3 id="非线程安全的Lazy-模式"><a href="#非线程安全的Lazy-模式" class="headerlink" title="非线程安全的Lazy 模式"></a>非线程安全的Lazy 模式</h3><p>采用延迟实例化的方式，能够将单例对象的构造延迟到第一次调用时。很显然，该方式是非线程安全（Non-Thread-Safe）的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">null</span>;  </div><div class="line">          </div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;  </div><div class="line">          </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </div><div class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </div><div class="line">                <span class="comment">// can be interrupted to other thread</span></div><div class="line">                singleton = <span class="keyword">new</span> Singleton();  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">return</span> singleton;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="线程安全的Lazy-模式"><a href="#线程安全的Lazy-模式" class="headerlink" title="线程安全的Lazy 模式"></a>线程安全的Lazy 模式</h3><p>在方法上加锁，能够保证该单例模式在多线程环境下的安全性，但是性能将严重受到影响。因为单例对象一旦创建就不需要同步读取获得对象上的互斥锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">        instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="基于静态内部类的方式"><a href="#基于静态内部类的方式" class="headerlink" title="基于静态内部类的方式"></a>基于静态内部类的方式</h3><p>内部静态类SingletonHolder 不会在Singleton 类被装载时就被实例化，需要在<em>getInstance()</em> 显示地被调用时才会被加载。因此，也可以实现Lazy 加载。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="基于DCL-的Lazy-模式"><a href="#基于DCL-的Lazy-模式" class="headerlink" title="基于DCL 的Lazy 模式"></a>基于DCL 的Lazy 模式</h3><p>DCL（Double Checked Locking）配合volatile 的使用进行双重检查，能够满足线程安全和延迟加载。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Lazy load thread safe</span></div><div class="line"> * Created by zhaoyu on 16-8-31.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckedLockingSingleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> DoubleCheckedLockingSingleton INSTANCE;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckedLockingSingleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> DoubleCheckedLockingSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (DoubleCheckedLockingSingleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</div><div class="line">                    INSTANCE = <span class="keyword">new</span> DoubleCheckedLockingSingleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="单例模式的使用场景"><a href="#单例模式的使用场景" class="headerlink" title="单例模式的使用场景"></a>单例模式的使用场景</h1><ul>
<li>项目中共享的访问点或共享的数据，如系统的配置信息</li>
<li>创建一个系统消耗过多资源的对象，例如访问IO和数据库等资源</li>
<li>Web 中采用单例模式保持计数器的值，并确保是线程安全的</li>
<li>生成唯一的序列ID 的场景</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>单例模式（Singleton Pattern）作为被广泛使用的一个模式，不仅能够减少系统的内存开销和提高系统的性能，还能够避免对系统资源的过多占用。在使用单例模式时一定要考虑是否在多线程环境下使用。目前，基于Enum 的实现是现在推荐的单例实现方式。总之，单例模式的使用需要在实际环境中根据需求选择合适的实现方式。</p>
<h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><ol>
<li><a href="https://zh.wikipedia.org/zh-cn/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">单例模式</a></li>
<li><a href="http://tramp-zzy.iteye.com/blog/1976102" target="_blank" rel="external">设计模式-单例模式-TRAMP_ZZY</a></li>
</ol>
<hr>
<p>本文章采用<a href="https://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可。<br>欢迎转载，但转载请注明来自<a href="https://zhangzhaoyu.github.io/">张兆玉</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文链接：<a href="https://zhangzhaoyu.github.io/2016/10/08/introduction-of-singleton-design-pattern/">https://zhangzhaoyu.github.io/2016/10/08/introduction-of-singleton-design-pattern/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;单例模式是一个既简单又复杂的模式。简单在它想实现的目标十分容易理解，而又复杂在要写出线程安全的单例模式不是那么容易。单例模式的核心定义是：确保某个类只有一个实例，并提供一个访问该实例的全局访问点(Ensure a class has only instance, and provide a global point of access to it)。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://zhangzhaoyu.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Singleton" scheme="https://zhangzhaoyu.github.io/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>Spring 寻根究底 - Spring 4.x Task 和 Schedule 概述</title>
    <link href="https://zhangzhaoyu.github.io/2016/09/30/spring-task-and-schedule-deep-research/"/>
    <id>https://zhangzhaoyu.github.io/2016/09/30/spring-task-and-schedule-deep-research/</id>
    <published>2016-09-30T13:53:00.000Z</published>
    <updated>2016-10-08T06:47:16.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在很多业务场景中，系统都需要用到任务调度系统。例如定期地清理Redis 缓存，周期性地检索某一条件并更新系统的资源等。在现代的应用系统中，快速地响应用户的请求，是用户体验最主要的因素之一。因此在Web 系统中异步地执行任务，也会在很多场景中经常涉及到。本文对任务调度和异步执行的Java 实现进行了总结，主要讲述一下内容：</p>
<ul>
<li>Java 对异步执行和任务调度的支持</li>
<li>Spring 4.X 的异步执行和任务调度实现</li>
</ul>
<a id="more"></a>
<h1 id="Java-对异步执行和任务调度的支持"><a href="#Java-对异步执行和任务调度的支持" class="headerlink" title="Java 对异步执行和任务调度的支持"></a>Java 对异步执行和任务调度的支持</h1><p>异步执行和任务调度底层的语言支撑都是Java 的多线程技术。线程是系统进行独立运行和调度的基本单位。拥有了多线程，系统就拥有了同时处理多项任务的能力。</p>
<h2 id="Java-实现异步调用"><a href="#Java-实现异步调用" class="headerlink" title="Java 实现异步调用"></a>Java 实现异步调用</h2><p>在Java 中要实现多线程有实现Runnable 接口和扩展Thread 类两种方式。只要将需要异步执行的任务放在run() 方法中，在主线程中启动要执行任务的子线程就可以实现任务的异步执行。如果需要实现基于时间点触发的任务调度，就需要在子线程中循环的检查系统当前的时间跟触发条件是否一致，然后触发任务的执行。该内容属于Java 多线程的基础知识，此处略过不讲。</p>
<h2 id="Java-Timer-和-TimeTask-实现任务调度"><a href="#Java-Timer-和-TimeTask-实现任务调度" class="headerlink" title="Java Timer 和 TimeTask 实现任务调度"></a>Java Timer 和 TimeTask 实现任务调度</h2><p>为了便于开发者快速地实现任务调度，Java JDK 对任务调度的功能进行了封装，实现了Timer 和TimerTask 两个工具类。</p>
<p><img src="/css/images/spring/timertask.png" alt="TimerTask 类"></p>
<p>由上图，我们可以看出TimeTask 抽象类在实现Runnable 接口的基础上增加了任务cancel() 和任务scheduledExecuttionTime() 两个方法。</p>
<p><img src="/css/images/spring/timer.png" alt="Timer 类"></p>
<p>上图为调度类Timer 的实现。从Timer类的源码，可以看到其采用TaskQueue 来实现对多个TimeTask 的管理。TimerThread 集成自Thread 类，其mainLoop() 用来对任务进行调度。而Timer 类提供了四种重载的schedule() 方法和重载了两种sheduleAtFixedRate() 方法来实现几种基本的任务调度类型。下面的代码是采用Timer 实现的定时系统时间打印程序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTimeTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="keyword">new</span> Date().toString());</div><div class="line">        &#125;</div><div class="line">                    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Timer timer = <span class="keyword">new</span> Timer(<span class="string">"hello"</span>);</div><div class="line">        timer.schedule(<span class="keyword">new</span> PrintTimeTask(), <span class="number">1000L</span>, <span class="number">2000L</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Spring-4-x-中的异步执行和任务调度"><a href="#Spring-4-x-中的异步执行和任务调度" class="headerlink" title="Spring 4.x 中的异步执行和任务调度"></a>Spring 4.x 中的异步执行和任务调度</h1><h2 id="Spring-4-x-中的异步执行"><a href="#Spring-4-x-中的异步执行" class="headerlink" title="Spring 4.x 中的异步执行"></a>Spring 4.x 中的异步执行</h2><p>Spring 作为一站式框架，为开发者提供了异步执行和任务调度的抽象接口<strong>TaskExecutor</strong> 和<strong>TaskScheduler</strong>。Spring 对这些接口的实现类支持线程池(Thread Pool) 和代理。<br>Spring 提供了对JDK 中Timer和开源的流行任务调度框架<a href="http://quartz-shceduler.org" target="_blank" rel="external">Quartz</a>的支持。Spring 通过将关联的Schedule 转化为FactoryBean 来实现。通过Spring 调度框架，开发者可以快速地通过<strong>MethodInvokingFactoryBean</strong> 来实现将POJO 类的方法转化为任务。</p>
<h3 id="Spring-TaskExecutor"><a href="#Spring-TaskExecutor" class="headerlink" title="Spring TaskExecutor"></a>Spring TaskExecutor</h3><p><strong>TaskExecutor</strong> 接口扩展自java.util.concurrent.Executor 接口。TaskExecutor 被创建来为其他组件提供线程池调用的抽象。</p>
<p><strong>ThreadPoolTaskExecutor</strong> 是TaskExecutor 的最主要实现类之一。该类的核心继承关系如下图所示。<br><img src="/css/images/spring/ThreadPoolTaskExecutor.png" alt="ThreadPooltaskexecutor 类"></p>
<p>ThreadPoolTaskExecutor 接口扩展了重多的接口，让其具备了更多的能力。要实现异步需要标注@Async 注解：</p>
<ul>
<li>AsyncTaskExecutor 增加了返回结果为Future 的submit() 方法，该方法的参数为Callable 接口。相比Runnable 接口，多了将执行结果返回的功能。</li>
<li>AsyncListenableTaskExecutor 接口允许返回拥有回调功能的ListenableFuture 接口，这样在结果执行完毕是，能够直接回调处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenableTask</span> </span>&#123;</div><div class="line">    <span class="meta">@Async</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ListenableFuture&lt;Integer&gt; <span class="title">compute</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            sum += i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(sum);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallBackImpl</span> <span class="keyword">implements</span> </span></div><div class="line">        <span class="title">ListenableFutureCallback</span>&lt;<span class="title">Integer</span>&gt; &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable ex)</span> </span>&#123;</div><div class="line">            System.out.println(ex.getMessage());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Integer result)</span> </span>&#123;</div><div class="line">            System.out.println(result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ListenableTask listenableTask = <span class="keyword">new</span> ListenableTask();</div><div class="line">        ListenableFuture&lt;Integer&gt; listenableFuture = </div><div class="line">            listenableTask.compute(<span class="number">10</span>);</div><div class="line">        listenableFuture.addCallback(<span class="keyword">new</span> CallBackImpl());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>ThreadFactory 定义了创建线程的工厂方法，可以扩展该方法实现对Thread 的改造。</li>
</ul>
<h3 id="基于Java-Config"><a href="#基于Java-Config" class="headerlink" title="基于Java Config"></a>基于Java Config</h3><ul>
<li><p><strong>基于注解</strong> 当采用基于Java Config 注解配置时，只需要在主配置添加@EnableAsync 注解，Spring 会自动的创建基于ThreadPoolTaskExecutor 实例注入到上下文中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableAsync</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>基于AsyncConfigurer接口自定义</strong> 开发者可以自定义Executor 的类型，并且注册异常处理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</div><div class="line">        executor.setMaxPoolSize(<span class="number">100</span>);</div><div class="line">        executor.setCorePoolSize(<span class="number">10</span>);</div><div class="line">        <span class="keyword">return</span> executor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncUncaughtExceptionHandler() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleUncaughtException</span><span class="params">(Throwable ex, </span></span></div><div class="line">                                                Method method, Object... params) &#123;</div><div class="line">                System.out.println(ex.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="基于XML-Config"><a href="#基于XML-Config" class="headerlink" title="基于XML Config"></a>基于XML Config</h3><ul>
<li><p><strong>基于传统XML的配置</strong> 基于XML 的形式，采用传统的Java Bean的形式配置ThreadPoolTaskExecutor。然后采用自动注入(autowire, resource,name)的可以直接在Spring Component 中注入Executor。以编程的形式实现异步任务。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"taskExecutor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.concurrent.</span></span></div><div class="line">    ThreadPoolTaskExecutor"&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"corePoolSize"</span> <span class="attr">value</span>=<span class="string">"5"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"queueCapacity"</span> <span class="attr">value</span>=<span class="string">"25"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>基于task 命名空间的配置</strong> Spring 为任务的执行提供了便利的task 命名空间。当采用基于XML 配置时Spring 会自动地为开发者创建Executor。同时可以在annotation-driven 标签上注册实现了AsyncUncaughtExceptionHandler 接口的异常处理器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- config exception handler  --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"taskAsyncExceptionHandler"</span> <span class="attr">class</span>=<span class="string">"org.zzy.spring4.application.schedulie.TaskAsyncExceptionHandler"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">exception-handler</span>=<span class="string">"taskAsyncExceptionHandler"</span> <span class="attr">scheduler</span>=<span class="string">"scheduler"</span> <span class="attr">executor</span>=<span class="string">"executor"</span>/&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="异步执行的异常处理"><a href="#异步执行的异常处理" class="headerlink" title="异步执行的异常处理"></a>异步执行的异常处理</h3><p>除了上文提到的两种异常处理方式，Spring 还提供了基于SimpleApplicationEventMulticaster 类的异常处理方式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> SimpleApplicationEventMulticaster <span class="title">eventMulticaster</span><span class="params">(TaskExecutor taskExecutor)</span> </span>&#123;</div><div class="line">    SimpleApplicationEventMulticaster eventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster();</div><div class="line">    eventMulticaster.setTaskExecutor(taskExecutor);</div><div class="line">    eventMulticaster.setErrorHandler(<span class="keyword">new</span> ErrorHandler() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleError</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">            System.out.println(t.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> eventMulticaster;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Spring-4-x-中任务调度实现"><a href="#Spring-4-x-中任务调度实现" class="headerlink" title="Spring 4.x 中任务调度实现"></a>Spring 4.x 中任务调度实现</h2><p>Spring 的任务调度主要基于<strong>TaskScheduler</strong> 接口。<strong>ThreadPoolTaskScheduler</strong> 是Spring 任务调度的核心实现类。该类提供了大量的重载方法进行任务调度。<strong>Trigger</strong> 定义了任务被执行的触发条件。Spring 提供了基于<a href="https://en.wikipedia.org/wiki/Cron" target="_blank" rel="external">Corn</a> 表达式的CornTrigger实现。TaskScheduler 如下图所示。<br><img src="/css/images/spring/taskscheduler.png" alt="ThreadPoolTaskExecutor 类"></p>
<p>实现<strong>TaskScheduler</strong> 接口的ThreadPoolTaskExecutor 继承关系。<br><img src="/css/images/spring/ThreadPoolTaskExecutor.png" alt="ThreadPoolTaskExecutor 类"></p>
<h3 id="基于Java-Config-1"><a href="#基于Java-Config-1" class="headerlink" title="基于Java Config"></a>基于Java Config</h3><ul>
<li><p><strong>基于注解的配置</strong> 当采用基于Java Config 注解配置时，只需要在主配置添加@EnableScheduling 注解，Spring 会自动的创建基于ThreadPoolTaskExecutor 实例注入到上下文中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableScheduling</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>基于SchedulingConfigurer接口自定义</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleConfig</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</div><div class="line">        taskRegistrar.setTaskScheduler(<span class="keyword">new</span> ThreadPoolTaskScheduler());</div><div class="line">        taskRegistrar.getScheduler().schedule(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"hello"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="keyword">new</span> CronTrigger(<span class="string">"0 15 9-17 * * MON-FRI"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="基于XML-Config-1"><a href="#基于XML-Config-1" class="headerlink" title="基于XML Config"></a>基于XML Config</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">scheduler</span>=<span class="string">"myScheduler"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"myScheduler"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span>/&gt;</span></div></pre></td></tr></table></figure>
<h3 id="Scheduled-注解的使用"><a href="#Scheduled-注解的使用" class="headerlink" title="@Scheduled 注解的使用"></a>@Scheduled 注解的使用</h3><p>当某个Bean 由Spring 管理生命周期时，就可以方便的使用@Shcheduled 注解将该Bean 的方法准换为基于任务调度的策略。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Scheduled</span>(initialDelay=<span class="number">1000</span>, fixedRate=<span class="number">5000</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// something that should execute periodically</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Scheduled</span>(cron=<span class="string">"*/5 * * * * MON-FRI"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// something that should execute on weekdays only</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="task-命名空间中的task-scheduled-tasks"><a href="#task-命名空间中的task-scheduled-tasks" class="headerlink" title="task 命名空间中的task:scheduled-tasks"></a>task 命名空间中的task:scheduled-tasks</h2><p>该元素能够实现快速地将一个普通Bean 的方法转换为Scheduled 任务的途径。具体如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">task:scheduled-tasks</span> <span class="attr">scheduler</span>=<span class="string">"myScheduler"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"beanA"</span> <span class="attr">method</span>=<span class="string">"methodA"</span> <span class="attr">fixed-delay</span>=<span class="string">"5000"</span> <span class="attr">initial-delay</span>=<span class="string">"1000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"beanB"</span> <span class="attr">method</span>=<span class="string">"methodB"</span> <span class="attr">fixed-rate</span>=<span class="string">"5000"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"beanC"</span> <span class="attr">method</span>=<span class="string">"methodC"</span> <span class="attr">cron</span>=<span class="string">"*/5 * * * * MON-FRI"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"myScheduler"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文着重介绍了JDK 为任务调度提供的基础类Timer。并在此基础上详细介绍了Spring 4.x 的异步执行和任务调度的底层接口设计。并针对常用的模式进行了讲解，并附带了源代码。第三方开源的Quartz 实现了更为强大的任务调度系统，Spring 也对集成Quartz 提供了转换。之后会择机再详细的介绍Quartz 的应用和设计原理。同时，Servlet 3.x 为Web 的异步调用提供了AsyncContext，对基于Web 的异步调用提供了原生的支持，后续的文章也会对此有相应的介绍。</p>
<h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><ol>
<li><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#scheduling" target="_blank" rel="external">Spring Doc Task and Schedule</a></li>
<li><a href="www.quartz-scheduler.org">Quartz</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cron" target="_blank" rel="external">Corn Wiki</a></li>
<li><a href="https://docs.oracle.com/javaee/7/api/javax/servlet/AsyncContext.html" target="_blank" rel="external">Servlet AsyncContext</a></li>
</ol>
<hr>
<p>本文章采用<a href="https://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可。<br>欢迎转载，但转载请注明来自<a href="https://zhangzhaoyu.github.io/">张兆玉</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文链接：<a href="https://zhangzhaoyu.github.io/2016/09/30/spring-task-and-schedule-deep-research/">https://zhangzhaoyu.github.io/2016/09/30/spring-task-and-schedule-deep-research/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;在很多业务场景中，系统都需要用到任务调度系统。例如定期地清理Redis 缓存，周期性地检索某一条件并更新系统的资源等。在现代的应用系统中，快速地响应用户的请求，是用户体验最主要的因素之一。因此在Web 系统中异步地执行任务，也会在很多场景中经常涉及到。本文对任务调度和异步执行的Java 实现进行了总结，主要讲述一下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java 对异步执行和任务调度的支持&lt;/li&gt;
&lt;li&gt;Spring 4.X 的异步执行和任务调度实现&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Spring 4.x" scheme="https://zhangzhaoyu.github.io/categories/Spring-4-x/"/>
    
    
      <category term="Schedule" scheme="https://zhangzhaoyu.github.io/tags/Schedule/"/>
    
      <category term="Task" scheme="https://zhangzhaoyu.github.io/tags/Task/"/>
    
  </entry>
  
  <entry>
    <title>流浪者和罂粟花</title>
    <link href="https://zhangzhaoyu.github.io/2016/09/27/tramp-and-poppy-flower/"/>
    <id>https://zhangzhaoyu.github.io/2016/09/27/tramp-and-poppy-flower/</id>
    <published>2016-09-27T15:00:00.000Z</published>
    <updated>2016-09-30T12:10:04.582Z</updated>
    
    <content type="html"><![CDATA[<p>天边的最后一丝光亮终于在黑暗笼罩世界的最后一刻消散在远处的那座山的背后。</p>
<p>渐渐地，世界暗下来了。</p>
<p>月亮清冷的在一朵浓黑的密云里发着幽幽灰光，那光亮好似冻彻心扉的坚冰，若隐若现的冒着丝丝白气，那白气在空中翻腾，扭曲，变形，幻化出许许多多魑魅魍魉，他们面目狰狞地飞向这个世界，唱着狂欢的笙歌，去吞噬，去冻结，去撕扯这个世界。<br><a id="more"></a><br>有一条小路在这轮孤月下面延伸，奔跑，不知道最终要去向的是哪个地方。小路旁边的有一盏灯火在暮色中亮起来。</p>
<p>透过那微弱的灯光，在窗户里面的一个圆桌子旁边围坐一家人，有个神情坚毅里透着憔悴的男人，有个体态瘦削却流露着母爱的女人，有个鼻子里流着鼻涕的小男孩正津津有味的吃着不知道是什么的东西。在小男孩的旁边有一只小狗欢快的摇着尾巴，看着小主人津津有味的吃着的东西，眼睛里有着自己绝对忠诚的小主人。</p>
<p>在这个有着一盏灯的小房子的后面，是一望无际的有着黄色土壤的田地。黑色的风绕过高山，掠过树梢，吹向了这片土地。</p>
<p>哗哗… 阵阵植物叶子簌簌地摩擦的声音，彼此起伏，蔓延开来。风掀起的黑色的叶子，呼啸着奔向对面的那片漆黑之中。</p>
<p>月亮渐渐地完全地被纯黑色的巨大黑幕所吞噬。</p>
<p>黑暗在世界任何一个角落里开着狂欢的派对。吸食着人们内心里最后的那么一点对于理想，自由，爱的追求。</p>
<p>恐慌，恐慌，满世界的恐慌。</p>
<p>黑暗，黑暗，满世界的黑暗。</p>
<p>在那个小屋子里的角落里，一个小男孩抱着一只懒洋洋的小狗甜甜地静静地在安睡。</p>
<p>那是一个美妙的梦，屋后面的那一望无际的植物终于开花了，在小男孩的爸爸妈妈付出了极其艰辛的劳动和汗水之后终于开花了。因为小男孩知道当这些个植物的开花的时候，肯定就是爸爸妈妈展开笑颜的时候了。</p>
<p>曾经很多个夜晚，小男孩对着夜空发呆，希望寻着一颗能够实现他愿望的星星。</p>
<p>在这个梦里，小男孩终于可以在花海奔跑，呵呵的笑声伴着小狗的汪汪叫声，在这片土地里延伸。</p>
<p>一群穿着黑色制服的人顺着那条小路向着这个黑暗里唯一的存在着微弱亮光的地方走来。</p>
<p>树影斑驳，人影可怖。</p>
<p>咚咚…</p>
<p>圆桌旁边男人，内心一惊，随后握紧了拳头。重重地压在桌子。旁边的妻子轻轻地把手放在男人的肩上。</p>
<p>“不要惊醒我的孩子，我们跟你们走！”。</p>
<p>吱吱…</p>
<p>门关上了。</p>
<p>四条人影在那条小道上前行，鞋子跟地面沙子摩擦的声音不时的响起，最后，最后，消失在远处的黑暗之中。</p>
<p>身后的那所小房子里，灯光依旧是那样地微弱。</p>
<p>只是，只是一个小男孩还有一个小狗依然静静地甜甜地睡着。</p>
<p>一夜的黑暗在太阳跳过对面山头的时候消失的无影无踪。</p>
<p>小男孩高兴地奔跑着去平时爸爸妈妈早上起来会去劳作的那片田地里，去告诉他们自己昨天做了一个美丽的梦。</p>
<p>时间渐渐过去了，小男孩有些心慌了，还不见爸爸妈妈。小狗在身后也嗷嗷地叫着，表示着不安。</p>
<p>小男孩疯狂地迈着小脚步在那片田地里穿梭。一朵朵美丽的花朵在他的眼前招摇，挡住了他寻找爸爸妈妈的视线。同时也淹没了小男孩小小身体。</p>
<p>黑夜渐渐地如梦魇般来到了。</p>
<p>在昨夜的那个小屋子里，再也没有了灯光。</p>
<p>哪怕是微弱的。</p>
<p>只是在那条路上站着一个小小男孩和一只小小狗。</p>
<p>在那条路上，小男孩决定去流浪，他没有眼泪，他不知掉为什么要流眼泪，为谁而流。小男孩反过身子，指着小狗，又指了一下与自己相对的另外与一个方向，狗狗很听话的把自己的头掉到了那个方向。</p>
<p>从此，便开始了两个生命体的流浪之旅。</p>
<p>两个身影消失在了夜色之中，只剩下那个小屋和午后的那片天地和田地里一望无际正开着花的植物。</p>
<p>匆匆的，时间流逝。那一个夜晚，那几个人物和故事，也归入到历史的洪流里，渐渐地渺小渺小，渺小到貌似不曾存在过。</p>
<p>一晃十几年过去了，过去了就是过去了。</p>
<p>后来的后来，有人看到了在那片山脚下，在那个曾经的小屋的后面的那片一望无际的田地里，每当植物开花的时候总有一个人影和一只狗游荡在那儿周围。他们的身影时隐实现在那一片罂粟花的海洋里。他们捍卫着在罂粟开花期的每一朵花，他们抵御了在罂粟花最美丽季节任何一个企图采摘哪怕一朵的破坏者。</p>
<p>一人一狗一片罂粟花。</p>
<hr>
<p>本文章采用<a href="https://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可。<br>欢迎转载，但转载请注明来自<a href="https://zhangzhaoyu.github.io/">张兆玉</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文链接：<a href="https://zhangzhaoyu.github.io/2016/09/27/tramp-and-poppy-flower/">https://zhangzhaoyu.github.io/2016/09/27/tramp-and-poppy-flower/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;天边的最后一丝光亮终于在黑暗笼罩世界的最后一刻消散在远处的那座山的背后。&lt;/p&gt;
&lt;p&gt;渐渐地，世界暗下来了。&lt;/p&gt;
&lt;p&gt;月亮清冷的在一朵浓黑的密云里发着幽幽灰光，那光亮好似冻彻心扉的坚冰，若隐若现的冒着丝丝白气，那白气在空中翻腾，扭曲，变形，幻化出许许多多魑魅魍魉，他们面目狰狞地飞向这个世界，唱着狂欢的笙歌，去吞噬，去冻结，去撕扯这个世界。&lt;br&gt;
    
    </summary>
    
      <category term="diary" scheme="https://zhangzhaoyu.github.io/categories/diary/"/>
    
    
      <category term="story" scheme="https://zhangzhaoyu.github.io/tags/story/"/>
    
  </entry>
  
  <entry>
    <title>雲中的故事</title>
    <link href="https://zhangzhaoyu.github.io/2015/05/03/story-of-the-cloud/"/>
    <id>https://zhangzhaoyu.github.io/2015/05/03/story-of-the-cloud/</id>
    <published>2015-05-03T04:12:12.000Z</published>
    <updated>2016-09-30T12:10:04.570Z</updated>
    
    <content type="html"><![CDATA[<p>飄泊的那朵雲</p>
<p>心里藏着珠兒</p>
<p>一滴是姑娘的淚</p>
<p>一滴是男子的血</p>
<p>淚珠說：我是姑娘溫婉憂傷的情</p>
<p>血珠說：我是男子堅毅孤獨的心</p>
<a id="more"></a>
<p>驚雷一声</p>
<p>淚珠說：我怕</p>
<p>血珠說：你抱着我</p>
<p>她溶進他的心</p>
<p>他感覺自己的心變得好重好重</p>
<p>隨著風蕩</p>
<p>落在山中古寺的一片瓦上</p>
<p>朝日初升</p>
<p>寺中梵音唱起</p>
<p>那滴小雨</p>
<p>對着日和着梵音在瓦上</p>
<p>微笑着再見</p>
<hr>
<p>本文章采用<a href="https://creativecommons.org/licenses/by/2.5/cn/" target="_blank" rel="external">知识共享署名 2.5 中国大陆许可协议</a>进行许可。<br>欢迎转载，但转载请注明来自<a href="https://zhangzhaoyu.github.io/">张兆玉</a>，并保持转载后文章内容的完整。本人保留所有版权相关权利。<br>本文链接：<a href="https://zhangzhaoyu.github.io/2015/05/03/story-of-the-cloud/">https://zhangzhaoyu.github.io/2015/05/03/story-of-the-cloud/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;飄泊的那朵雲&lt;/p&gt;
&lt;p&gt;心里藏着珠兒&lt;/p&gt;
&lt;p&gt;一滴是姑娘的淚&lt;/p&gt;
&lt;p&gt;一滴是男子的血&lt;/p&gt;
&lt;p&gt;淚珠說：我是姑娘溫婉憂傷的情&lt;/p&gt;
&lt;p&gt;血珠說：我是男子堅毅孤獨的心&lt;/p&gt;
    
    </summary>
    
      <category term="diary" scheme="https://zhangzhaoyu.github.io/categories/diary/"/>
    
    
      <category term="story" scheme="https://zhangzhaoyu.github.io/tags/story/"/>
    
  </entry>
  
</feed>
